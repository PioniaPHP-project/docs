[{"content":"Well-thought-through product announcements will help increase feature awareness and engage users with new functionality. Just like sharing your public roadmap, it\u0026rsquo;s also a great way to let potential customers see that you\u0026rsquo;re constantly improving.\nFurther reading Read How to announce product updates and features ","date":"2023-09-07","id":0,"permalink":"/blog/example-post/","summary":"You can use blog posts for announcing product updates and features.","tags":[],"title":"Example Post"},{"content":"","date":"2023-09-07","id":1,"permalink":"/blog/","summary":"","tags":[],"title":"Blog"},{"content":"MoonLight is a rather new architecture that is based on the commonly used architectures of gRPC, MVC(Model View Controller), Micro-Services and Monolothic. It picks the best of all these architectures and combines them to create a new architecture that is more efficient and scalable.\nThe MoonLight paradigm Below are the new conventions that MoonLight architecture brings to the table:\nArchitecture Overview\nThe car scenario! \u0026ndash; 1\nImagine a scenario of a car, the car can have passengers and multiple passengers. The job of the driver is to controll the rest of the car, and the passengers to behave themselves and not interfere with the driver. The driver has one steering wheel in the entire car. Some cars may have a conductor who is responsible for the passengers instead of the driver. This helps the driver to focus on the road and not the passengers.\nThe traffic scenario! \u0026ndash; 2\nBased on the scenario above, the driver is stopped by the traffic police man, the polica man moves to the driver\u0026rsquo;s side and not the passengers side. The police man looks through the driver\u0026rsquo;s window and checks if there are any issues with the passengers. He asks the first passenger to pass over their id, the passenger forwards the id to the driver who then hands it over to the police. He checks and gives it to the driver who then hands it over to the passenger.\nNOTE Remember the above scenarios as we dive into the MoonLight architecture\n1. Single API endpoint/route In the moonlight, all requests target the same endpoint. This is to ensure that the application is scalable and easy to maintain. This also makes it easier to debug and monitor the application.\nAssuming the application is running on http://localhost:3000, all requests will be made to http://localhost:3000/api/v1/. This is the only endpoint that is exposed to the outside world.\nOn top of other advantages, now frontend devs don\u0026rsquo;t have to worry about the base URL of the API. They can just make requests to the /api/v1/ endpoint and the application will handle the rest.\nPoint To Ponder!\nThis is our drivers window in the car scenario.\nFor anyone to interact with the application, they must go through this endpoint only.\n2. POST Requests only All requests under moonlight architecture are made using the http method of POST only. This is to ensure that the requests are secure and the data is not exposed in the server logs or in the URL. This also makes it easier to debug and monitor the application. Read more on security.\n3. Single Request Format In Moonlight architecture, all requests are made in a similar format. This makes it easier to understand and debug the requests. Requests can either be be of type JSON or form-data.\nEvery request must define the SERVICE and ACTION to exacute in the request body plus the rest rest of the payload as required by the service.\nPOST http://localhost:3000/api/v1/\r{ \u0026#34;SERVICE\u0026#34;: \u0026#34;users\u0026#34;, \u0026#34;ACTION\u0026#34;: \u0026#34;get_user_by_profile\u0026#34;, \u0026#34;profile\u0026#34;: \u0026#34;@1233232\u0026#34; }\rThe SERVICE and ACTION are required in every request. The rest of the payload is dependent on the service and action being executed.\nPoint To Ponder!\nThis architecture, if to be well implemented must follow the Object Oriented Programming paradigm. With this, services should/must be classes or interfaces(golang) that combine together related business logic like AuthenticationService, ProductService, OrderService etc.\nAnd Actions should be methods in these classes like login, register in the AuthenticationService class.\n4. Single Response Format This architecture also calls for a single response format. This makes it way easier to understand and debug the responses. The response format is as follows:\nResponse\r{ \u0026#34;statusCode\u0026#34;: 0, \u0026#34;returnMessage\u0026#34;: \u0026#34;Some cool message here or null\u0026#34;, \u0026#34;returnData\u0026#34;: \u0026#34;the data you\u0026#39;re sending to the frontend\u0026#34;, \u0026#34;extraData\u0026#34;: \u0026#34;any extra data you want to send to the frontend\u0026#34; }\rWith statusCode, it implies that the developer/business can define their own custom status codes. However, by convention, a status code of 0 implies success and is recommended to be kept for the same.\n5. HTTP 200 OK for all. All requests in this architecture that reach the application server should/must return an http status of 200 OK. The only special case is 502 Gateway Error which is returned when the application server is down or unreachable.\nPoint To Ponder!\nThink about it, the application server actually handled your request so whether the request raised an exception or successfully executed, the server actually handled. And that\u0026rsquo;s what we are actually looking for.\nRemember the traffic scenario!\nEvery time our police man poses a question, he expects an answer. If the driver doesn\u0026rsquo;t have an answer, he should say so(which is also an answer) and not just keep quiet.\n6. Single Controller Per Application. In this architecture, there is only one controller that handles all the requests. This controller is responsible for routing the requests to the appropriate service and action. This makes it easier to maintain and debug the application. This must be one per application.\nTo achieve api versioning, this controller can have multiple actions each pointing to a different version of the application. Each action can then route the request to the appropriate service switch. It is at this point that the app should handle all exceptions that might be raised by the services and then return a 200 OK response with the appropriate message.\nExample using php.\nController\rclass ApiController extends Controller { public function v1() { try { // point to the service switch for version one } catch (\\Exception $e) { // handle the exception here } } public function v2() { try { // point to the service switch for version two } catch (\\Exception $e) { // handle the exception here } } } \u0026lt;?php\rNo logic should be in the controller, it should only be responsible for routing the requests to the appropriate service and action.\nPoint To Ponder!\nThis is the driver in the car scenario. The driver is responsible for routing the police man questions to the appropriate passenger.\nThe steering wheel is the controller action of the version we are targeting!\n7. Single Service Switch Per API Version. In this architecture, there should only be one service switch that handles all the requests for a particular version of the application. This service switch is responsible reading the SERVICE in the request and the call the responsible service passing it the action(ACTION) and the rest of the payload.\nThe service switch is just a convention to make our controller clean and easy to maintain. It is not a must to have it, but it is recommended. Otherwise, the switching logic would be handled in the controller action responsible for the version.\nPoint To Ponder!\nThis is the conductor in the car scenario. However much the driver can do everything the conductor can do, the conductor is their to reduce work load on the driver.\nThis implies the driver focuses on the road and the conductor focuses on the passengers.\nThe controller focuses on the mapping the request, the service switch focuses on mapping the service and the action.\n8. Services and Actions In MoonLight architecture, services are classes or interfaces that combine together related business logic. For example, AuthenticationService, ProductService, OrderService etc.\nActions are methods in these classes like login, register in the AuthenticationService class.\nPoint To Ponder!\nThis is the passenger in the car scenario. The passenger is responsible for their own luggage and reaching their destination. They are also responsible for fullfiling the driver\u0026rsquo;s requests.\nRemember, the driver asks the passenger for the id, the passenger passed it over to the driver! Passing the id is the passenger\u0026rsquo;s responsibility(action).\n9. Database and Querying In moonlight architecture, querying the database is highly recommended over using an ORM. This is because querying the database directly is faster and more efficient than using an ORM. Also, querying the database directly gives the developer more control over the queries and the data being returned.\nGet started with the Moonlight Implementation using Pionia.\n10. Separation of Concerns In this architecture, the backend is meant to support, command and act as a single source of truth for the frontend. This implies that the architecture requires implementers to implement the frontend and backend separately.\nAdvantages of MoonLight Architecture Scalability :- Since adding new services and actions is easy, the application can be scaled easily. Maintainability :- Small codebase and single-logic services make it easy to maintain the application. Even new developers can easily understand the codebase. Security :- Since all requests are made using POST, the data is secure and not exposed in the URL. Also, action level authentication makes it easy to secure the application. High Performance :- This is as a result of less abstraction and more direct database querying. Also, the architecture improves the developer performance since it reduces the codebase of the previously used architectures by almost 60%. Easy Debugging :- Since all requests and responses are made in a similar format, it is easy to debug the application. Frontend Integration :- One endpoint for all requests, one request format, one response format make it easy for frontend devs to integrate the api. Disadvantages of MoonLight Architecture Some languages may not support switching between form-data and json requests. This might dictate all uploads to be base64 encoded. Moonlight is only suitable for APIs and not for fullstack applications. The architecture being new, there might be a learning curve for new developers and a small community to get help from. The community is growing and we are looking forward to having you on board.\n","date":"2024-05-24","id":2,"permalink":"/moonlight-architecture/","summary":"MoonLight is a rather new architecture that is based on the commonly used architectures of gRPC, MVC(Model View Controller), Micro-Services and Monolothic.","tags":[],"title":"MoonLight Architecture"},{"content":"Introdution All requests sent to the server over https get encrypted and decrypted on the web server level. This ensures that attacks like man-in-the-middle are mitigated. This applies for all requests sent to the server whether via GET, POST, PUT, DELETE or any other method. On the server level, every request is logged. These logs omit the request body and only log domain, path, query params and headers. This ensures that the data is secure and not exposed in the URL.\nWe need this logging for debugging purposes, therefore, we might not choose to turn it off.\nExample below shows how the logs are stored in the server:\n1 2 3 4 5 6 7 8 9 10 { \u0026#34;domain\u0026#34;: \u0026#34;example.com\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;/api/v1/user\u0026#34;, \u0026#34;query\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34; }, \u0026#34;headers\u0026#34;: { \u0026#34;content-type\u0026#34;: \u0026#34;application/json\u0026#34; } } This is where we have our first problem that we need to address. The query params are logged in the web server level. This is a security risk.\nHowever much this is is a rare case, imagine logging in via a GET request as below:\nhttps://example.com/api/v1/login?username=example\u0026amp;password=example\rThe parameters username and password are logged in the web server level in the raw format. This implies that, however much the passwords are encrypted in the database, they are exposed in the logs. Any malicious user with access to the logs can easily get the password and username.\nAs a result, the architecture encourages to perform all requests over POST. This is because POST requests\u0026rsquo; body is not logged in the web server level. This ensures that the data is secure.\nThis is a supplement to the single endpoit approach of MoonLight architecture.\nHTTP level security - POST Requests only With this in mind, the architecture encourages to perform all requests over POST. This is because POST requests\u0026rsquo; body is not logged in the web server level. This ensures that the data is secure.\nSample moonlight request:\n{ \u0026#34;domain\u0026#34;: \u0026#34;example.com\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;/api/v1/\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;POST\u0026#34;, \u0026#34;body\u0026#34;: { \u0026#34;username\u0026#34;: \u0026#34;example\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;example\u0026#34;, \u0026#34;action\u0026#34;: \u0026#34;login\u0026#34;, \u0026#34;service\u0026#34;: \u0026#34;auth\u0026#34;, } }\rThe above request is secure as the body is not logged in the web server level. This removes the only security risk that ssl encryption does not cover.\nAction Level Security Unlike most architectures, in moonlight, securing actions happens at the action level. This means that requests are let through whether authenticated or not. The action itself determines whether the request is authenticated or not.\nIf an action say, addCart requires a certain permission, the action itself mentions it. Therefore, actions are not protected globally but rather internally(on the method level).\nExample below shows how an action can be protected in pionia:\nclass TodoService extends BaseRestService { // your other actions here public function getTodo() { $this-\u0026gt;can(\u0026#39;view-todo\u0026#39;); // user must have the permission to view todo // your action here } }\rIn the above example, the action getTodo requires the user to have the permission view-todo. If the user does not have the permission, the action will not be executed. As observed, the action itself determines whether the request is authenticated or not.\n","date":"2024-05-24","id":3,"permalink":"/security-in-moonlight/","summary":"All requests sent to the server get encrypted and decrypted on the web server level. This ensures that the data is secure and not exposed in the URL. However, all query params are logged in the web server level, the architecture encourages to perform all requests over POST.","tags":[],"title":"Security in moonlight"},{"content":"Introdution Moonlight basically has only one controller, one controller action and one endpoint. To get another version of the api, you just need to roll out a new controller action and a new endpoint. This is how moonlight approaches api versioning.\nBasing on pionia implementation, the architecture has only one controller.\n\u0026lt;?php class Controller extends BaseApiController { /** * This is where the only action we need for our controller. * * It will map all post request targeting /api/v1/ to responsible services. * * @param Request $request * @return BaseResponse */ public function apiV1(Request $request): BaseResponse { try { return MainApiSwitch::processServices($request); } catch (Exception $e) { return BaseResponse::JsonResponse(400, $e-\u0026gt;getMessage()); } } }\r","date":"2024-05-24","id":4,"permalink":"/versioning-in-moonlight/","summary":"Moonlight basically has only one controller, one controller action and one endpoint. To get another version of the api, you just need to roll out a new controller action and a new endpoint. This is how moonlight approaches api versioning.","tags":[],"title":"Versioning in moonlight"},{"content":"\r","date":"2023-09-07","id":5,"permalink":"/docs/documentation/","summary":"\r","tags":[],"title":"Documentation"},{"content":"\rThis section assumes that you have already setup your pinia framework project. If you haven\u0026rsquo;t done done, please head over to Installation.\nThis guide also introduces you to the implementation of the Moonlight architecture, so you can check it out first to get familiar with the terminologies.\nOut Target We should be able to accomplish the following tasks by the end of this tutorial:\nIntialise the project. Connect to a database. Create a service. Create or update a to-do item in the database. Retrieve all to-do items from the database. Retrieve a single to-do item from the database. Retrieve n random to-do item[s] from the database. Delete a to-do item from the database. Prerequisites You should have a basic understanding of PHP. You should have postman installed on your machine for testing the API. You should have a database created already. Step 1: Initialize the project To create a new project, you need to run the following command in the directory you want your project to be created. We are calling ours todo_api.\ncomposer create-project pionia/pionia-app todo_api\rWe can open the project in our favorite code editor or IDE, for this tutorial we will be using PhPStorm IDE.\nAll IDEs and Editors should be okay to use since Pionia is powered by PHP that is supported by most of the IDEs.\nFor explanation of the directories and scripts, please refer to the Structure Section of this documentation.\nIntialise the project(Completed) Step 2: Connect to a database Pionia removes the section of models and migrations and instead uses a simple and lightweight query builder to interact with the database - PORM.\nAt its heart, PORM is a wrapper on top of medoo, a lightweight database framework that makes interacting with the database easy and fun.\nYou can create a new database or use an existing one as you see fit!\nAssuming you have already setup your MySQL database.\nLet\u0026rsquo;s first create our MySQL database as below:\nCREATE DATABASE todo_db; USE todo_db;\rThen we can create a table called todos as below:\ncreate table if not exists todos ( id int auto_increment primary key, title varchar(200) not null, description text, created_at timestamp default CURRENT_TIMESTAMP ); desc todos;\rAbove should return the following:\nOpen settings.ini file and update the database settings as below:\nsettings.ini\r[db] database = \u0026#34;todo_db\u0026#34; # your database name username = \u0026#34;root\u0026#34; # your database user type = \u0026#34;mysql\u0026#34; # your database type host = \u0026#34;localhost\u0026#34; password = \u0026#34;\u0026#34; # your database password port = 3306\rConnect to a database(Completed) Throughout this tutorial, we will be creating everything manually, however, pionia cli can be used to create most of the staff for you.\nJust run the following command in your terminal to see the available commands.\nphp pionia\rStep 3: Create the service - TodoService Since all our business logic is related to To-do items, we only need one service called TodoService. Head over to services directory and add the following code to TodoService.php. All our services should extend BaseRestService class.\nTodoService.php\r\u0026lt;?php namespace application\\services; use Pionia\\request\\BaseRestService; class TodoService extends BaseRestService { }\rAfter creating our service, we need to register it in the MainApiSwitch class. Open MainApiSwitch.php and add the following code:\nMainApiSwitch.php\rpublic function registerServices(): array { return [ \u0026#39;user\u0026#39; =\u0026gt; new UserService(), \u0026#34;todo\u0026#34; =\u0026gt; new TodoService(), // add this line here ]; }\rNow our service is discoverable by the framework.\nCreate the service(Completed) Step 4: Create or update a to-do item in the database - 1st action. We create our first action in our service called \u0026lsquo;createOrUpdate\u0026rsquo;. This action will be responsible for creating a new to-do item in the database or update an existing one if an id is provided.\nTodoService.php\rnamespace application\\services; use Pionia\\request\\BaseRestService; class TodoService extends BaseRestService { public function createOrUpdate($data) : BaseResponse { $title = $data[\u0026#39;title\u0026#39;]; $description = $data[\u0026#39;description\u0026#39;]; $id = $data[\u0026#39;id\u0026#39;] ?? null; if (!$id) { // here we can create $saved = Porm::from(\u0026#34;todos\u0026#34;) -\u0026gt;save([ \u0026#39;title\u0026#39; =\u0026gt; $title, \u0026#39;description\u0026#39; =\u0026gt; $description, ]); } else { // here we can update Porm::from(\u0026#34;todos\u0026#34;) -\u0026gt;update([ \u0026#39;title\u0026#39; =\u0026gt; $title, \u0026#39;description\u0026#39; =\u0026gt; $description, ], $id); $saved = Porm::from(\u0026#34;todos\u0026#34;) -\u0026gt;get($id); } return BaseResponse::JsonResponse(0, \u0026#34;Todo $saved-\u0026gt;title created.\u0026#34;, $saved); } }\rSending the request using any client of choice.\nAxios FormData(postman)\rAxios JSON Data(Postman)\rXHR -JSON (Postman)\rconst axios = require(\u0026#39;axios\u0026#39;); const FormData = require(\u0026#39;form-data\u0026#39;); let data = new FormData(); data.append(\u0026#39;title\u0026#39;, \u0026#39;Pass this \u0026#39;); data.append(\u0026#39;description\u0026#39;, \u0026#39;Must pass this\u0026#39;); data.append(\u0026#39;SERVICE\u0026#39;, \u0026#39;todo\u0026#39;); data.append(\u0026#39;ACTION\u0026#39;, \u0026#39;create\u0026#39;); let config = { method: \u0026#39;post\u0026#39;, maxBodyLength: Infinity, url: \u0026#39;http://localhost:8000/api/v1/\u0026#39;, headers: { ...data.getHeaders() }, data : data }; axios.request(config) .then((response) =\u0026gt; { console.log(JSON.stringify(response.data)); }) .catch((error) =\u0026gt; { console.log(error); });\rconst axios = require(\u0026#39;axios\u0026#39;); let data = JSON.stringify({ \u0026#34;SERVICE\u0026#34;: \u0026#34;todo\u0026#34;, \u0026#34;ACTION\u0026#34;: \u0026#34;create\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;Become an avenger\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Make sure you become an avenger at 10!\u0026#34; }); let config = { method: \u0026#39;post\u0026#39;, maxBodyLength: Infinity, url: \u0026#39;http://localhost:8000/api/v1/\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, data : data }; axios.request(config) .then((response) =\u0026gt; { console.log(JSON.stringify(response.data)); }) .catch((error) =\u0026gt; { console.log(error); });\rvar data = JSON.stringify({ \u0026#34;SERVICE\u0026#34;: \u0026#34;todo\u0026#34;, \u0026#34;ACTION\u0026#34;: \u0026#34;create\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;Become an avenger\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Make sure you become an avenger at 10!\u0026#34; \u0026#34;id\u0026#34;: 2 // this is optional, only pass it to update. }); var xhr = new XMLHttpRequest(); xhr.withCredentials = true; xhr.addEventListener(\u0026#34;readystatechange\u0026#34;, function() { if(this.readyState === 4) { console.log(this.responseText); } }); xhr.open(\u0026#34;POST\u0026#34;, \u0026#34;http://localhost:8000/api/v1/\u0026#34;); xhr.setRequestHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;);\rOn Successful execution, the above code should return the following:\n{ \u0026#34;returnCode\u0026#34;: 0, \u0026#34;returnMessage\u0026#34;: \u0026#34;Todo Become an avenger created.\u0026#34;, \u0026#34;returnData\u0026#34;: { \u0026#34;id\u0026#34;: 2, \u0026#34;title\u0026#34;: \u0026#34;Become an avenger\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Make sure you become an avenger at 10!\u0026#34;, \u0026#34;created_at\u0026#34;: \u0026#34;2024-05-26 00:11:23\u0026#34; }, \u0026#34;extraData\u0026#34;: \u0026#34;2\u0026#34; }\rAnd in the database, we should have the following:\nBefore we proceed, let\u0026rsquo;s first understand what just happened above.\nWhen you hit the endpoint http://localhost:8000/api/v1/ with the data as shown above, the request came via our index.php, which checked out routes. We only have one route as follows:-\nroutes.php\r$router-\u0026gt;addGroup(\u0026#39;application\\Controller\u0026#39;) -\u0026gt;post(\u0026#39;apiV1\u0026#39;, \u0026#39;api_version_one\u0026#39;);\rThe above route implies that all post requests to our only controller should be handled by an action(method) named \u0026lsquo;apiV1\u0026rsquo;.\nTherefore, in our controller, the following method was executed:\nController.php\rpublic function apiV1(Request $request): BaseResponse { try { return MainApiSwitch::processServices($request); } catch (Exception $e) { return BaseResponse::JsonResponse(400, $e-\u0026gt;getMessage()); } }\rThe above does two things:\nMaps the whole request to the MainApiSwitch class which is our service registry for v1. It helps to map the request to the service mentioned.\nCatches any exception that might be thrown during the process and returns a 200 OK response with a returnCode of 400.\nYou can also add logic here as you see fit. But we recommend you keep it as clean as possible.\nThe main api switch checks in the request body for the SERVICE and ACTION keys. If they are not found, it throws an exception. If they are found, it maps the request to the service and action mentioned basing on the registered services. Therefore, for your service to be discovered, you must register it as we did here.\nMainApiSwitch.php\rpublic function registerServices(): array { return [ \u0026#39;user\u0026#39; =\u0026gt; new UserService(), \u0026#34;todo\u0026#34; =\u0026gt; new TodoService(), // this is our service. ]; }\rSo, after here, the service needed is loaded and the entire request in forwarded to it. When the service receives the request, it checks for the action mentioned in the request body. If the action is not found, it throws an exception. If the action is found, it executes the action and returns a response back to the MainApiSwitch which then returns the response to the controller which then returns the response to the kernel that does final processing and returns the response to the client.\nCreate or update a to-do item in the database(Completed) Step 5: Retrieve all to-do items from the database - 2nd action. We created our todo from the above step, please first take time to create as many as you want.\nNow, let\u0026rsquo;s create an action called all in our service to retrieve all to-do items from the database.\nTodoService.php\r## ..rest of the service code public function all() : BaseResponse { $data = Por::from(\u0026#34;todos\u0026#34;)-\u0026gt;all(); return BaseResponse::JsonResponse(0, \u0026#34;Todos found.\u0026#34;, $data); } ## rest of the service code... Now, let\u0026rsquo;s change our JSON in postman to the following:\n{ \u0026#34;SERVICE\u0026#34;: \u0026#34;todo\u0026#34;, \u0026#34;ACTION\u0026#34;: \u0026#34;all\u0026#34; }\rSend the request and you should get the following response:\n{ \u0026#34;returnCode\u0026#34;: 0, \u0026#34;returnMessage\u0026#34;: \u0026#34;Todos found.\u0026#34;, \u0026#34;returnData\u0026#34;: [ { \u0026#34;id\u0026#34;: 1, \u0026#34;title\u0026#34;: \u0026#34;Pass this \u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Must pass this\u0026#34;, \u0026#34;created_at\u0026#34;: \u0026#34;2024-05-26 00:04:17\u0026#34; }, { \u0026#34;id\u0026#34;: 2, \u0026#34;title\u0026#34;: \u0026#34;Become an avenger\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Make sure you become an avenger at 10!\u0026#34;, \u0026#34;created_at\u0026#34;: \u0026#34;2024-05-26 00:11:23\u0026#34; } ], \u0026#34;extraData\u0026#34;: null }\rPoint To Ponder\nNotice how the returnData is an array yet it was an object in the previous response. returnData and extraData can be of any type, it is up to you to decide what to return in them.\nYou can also omit the message by setting it to null which should be logical for cases of listing items.\nRetrieve all to-do items from the database(Completed) Step 6: Retrieve a single to-do item from the database - 3rd action. We will create an action called one in our service to retrieve a single to-do item from the database.\nTodoService.php\r## ..rest of the service code /** * @throws DatabaseException */ public function one($data) : BaseResponse { $id = $data[\u0026#39;id\u0026#39;]; $res = Porm::from(\u0026#39;todos\u0026#39;) -\u0026gt;get($id); // or Porm::from(\u0026#39;todos\u0026#39;)-\u0026gt;get([\u0026#39;id\u0026#39; =\u0026gt; $id]); if ($res) { return BaseResponse::JsonResponse(0, null, $data); } else { throw new DatabaseException(\u0026#34;No todo with id $id found.\u0026#34;); } } ## ..rest of the service code Here we are going to test two scenarios, one is where everything goes smoothly and the other is where the server panics(throws an exception).\n{ \u0026#34;SERVICE\u0026#34;:\u0026#34;todo\u0026#34;, \u0026#34;ACTION\u0026#34;: \u0026#34;one\u0026#34;, \u0026#34;id\u0026#34;: 2 }\r{ \u0026#34;SERVICE\u0026#34;: \u0026#34;todo\u0026#34;, \u0026#34;ACTION\u0026#34;: \u0026#34;one\u0026#34;, \u0026#34;id\u0026#34;: 100 }\rIn the first scenario, we get back a status code of 200 OK but with the following response.\n{ \u0026#34;returnCode\u0026#34;: 0, \u0026#34;returnMessage\u0026#34;: null, \u0026#34;returnData\u0026#34;: { \u0026#34;SERVICE\u0026#34;: \u0026#34;todo\u0026#34;, \u0026#34;ACTION\u0026#34;: \u0026#34;one\u0026#34;, \u0026#34;id\u0026#34;: 2 }, \u0026#34;extraData\u0026#34;: null }\rBut in the second scenario, we still get a status code of 200 OK but with the following response.\n{ \u0026#34;returnCode\u0026#34;: 400, \u0026#34;returnMessage\u0026#34;: \u0026#34;No todo with id 100 found.\u0026#34;, \u0026#34;returnData\u0026#34;: null, \u0026#34;extraData\u0026#34;: null }\rPoint To Ponder\nNotice how the exception message becomes our returnMessage. This exception was caught by our controller. Therefore, wherever you\u0026rsquo;re in the services, feel free to throw any exceptions with clean messages.\nRetrieve a single to-do item from the database(Completed) Step 7: Grab n random to-do item[s] from the database - 7th action. TodoService.php\r## ..rest of the service code public function random($data) : BaseResponse { $length = $data[\u0026#39;length\u0026#39;] ?? 1; $porm = Porm::from(\u0026#34;todos\u0026#34;) -\u0026gt;random($length); return BaseResponse::JsonResponse(0, \u0026#34;Todos found.\u0026#34;, $porm); }\rYou can keep hitting this action and on each hit, you should get a different to-do item. You can also play with the length parameter to get more or less to-do items.\n{ \u0026#34;SERVICE\u0026#34;: \u0026#34;todo\u0026#34;, \u0026#34;ACTION\u0026#34;: \u0026#34;random\u0026#34;, \u0026#34;length\u0026#34;: 1 }\rGrab n random to-do item[s] from the database(Completed) Step 8: Delete a to-do item from the database - 5th action. If you followed along upto this far, you should be able to implement this on your own. If you get stuck, you can refer to the code below.\nTodoService.php\rpublic function delete($data) : BaseResponse { $id = $data[\u0026#39;id\u0026#39;]; Porm::from(\u0026#34;todos\u0026#34;)-\u0026gt;delete($id); // you can now hit \u0026#39;all\u0026#39; to see if this worked, // you should notice item with this id disappears. return BaseResponse::JsonResponse(0, \u0026#34;Todo deleted.\u0026#34;); }\rChange your request object to the following in your client(postman).\n{ \u0026#34;SERVICE\u0026#34;: \u0026#34;todo\u0026#34;, \u0026#34;ACTION\u0026#34;: \u0026#34;delete\u0026#34;, \u0026#34;id\u0026#34;: 2 }\rIf you did everything right, you should get your response as follows\n{ \u0026#34;returnCode\u0026#34;: 0, \u0026#34;returnMessage\u0026#34;: \u0026#34;Todo deleted.\u0026#34;, \u0026#34;returnData\u0026#34;: null, \u0026#34;extraData\u0026#34;: null }\rDelete a to-do item from the database(Completed) Point To Ponder\nAll our requests are made via POST method. All our requests have similar body structure, they have a SERVICE, ACTION, and other param keys. All our responses have the same response format, returnCode, returnMessage, returnData, and extraData keys. We are hitting the same endpoint http://localhost:8000/api/v1/ for all our requests. We did not touch the controller, routes, or the kernel. but we only focused on the service! This is the beauty of the Moonlight architecture. It makes it easy to understand and maintain your code.\nImagine how fast you would pull off a new service with Pionia.\nFull Service Source Code Details\rTodoService.php\r\u0026lt;?php namespace application\\services; use Exception; use Pionia\\exceptions\\DatabaseException; use Pionia\\request\\BaseRestService; use Pionia\\response\\BaseResponse; use Porm\\exceptions\\BaseDatabaseException; use Porm\\Porm; class TodoService extends BaseRestService { /** * @throws BaseDatabaseException * @throws Exception */ public function createOrUpdate($data) : BaseResponse { $title = $data[\u0026#39;title\u0026#39;]; $description = $data[\u0026#39;description\u0026#39;]; $id = $data[\u0026#39;id\u0026#39;] ?? null; if (!$id) { // here we can create $saved = Porm::from(\u0026#34;todos\u0026#34;) -\u0026gt;save([ \u0026#39;title\u0026#39; =\u0026gt; $title, \u0026#39;description\u0026#39; =\u0026gt; $description, ]); } else { // here we can update Porm::from(\u0026#34;todos\u0026#34;) -\u0026gt;update([ \u0026#39;title\u0026#39; =\u0026gt; $title, \u0026#39;description\u0026#39; =\u0026gt; $description, ], $id); $saved = Porm::from(\u0026#34;todos\u0026#34;) -\u0026gt;get($id); } return BaseResponse::JsonResponse(0, \u0026#34;Todo $saved-\u0026gt;title created.\u0026#34;, $saved); } /** * @throws BaseDatabaseException * @throws Exception */ public function all() : BaseResponse { $data = Porm::from(\u0026#34;todos\u0026#34;) -\u0026gt;all(); return BaseResponse::JsonResponse(0, \u0026#34;Todos found.\u0026#34;, $data); } /** * @throws Exception */ public function one($data) : BaseResponse { $id = $data[\u0026#39;id\u0026#39;]; $res = Porm::from(\u0026#39;todos\u0026#39;) -\u0026gt;get($id); if ($res) { return BaseResponse::JsonResponse(0, null, $data); } else { throw new DatabaseException(\u0026#34;No todo with id $id found.\u0026#34;); } } /** * @throws BaseDatabaseException */ public function delete($data) : BaseResponse { $id = $data[\u0026#39;id\u0026#39;]; Porm::from(\u0026#34;todos\u0026#34;)-\u0026gt;delete($id); // you can now hit all to see if this worked, // you should notice item with this id disappears. return BaseResponse::JsonResponse(0, \u0026#34;Todo deleted.\u0026#34;); } /** * @throws Exception */ public function random($data) : BaseResponse { $length = $data[\u0026#39;length\u0026#39;] ?? 1; $porm = Porm::from(\u0026#34;todos\u0026#34;) -\u0026gt;random($length); return BaseResponse::JsonResponse(0, \u0026#34;Todos found.\u0026#34;, $porm); } }\rPost Tutorial \u0026ndash; What Next? Deep Dive into Pionia Requests\rExplore more features about the Pionia Requests and the request cycle.\n","date":"2024-05-24","id":6,"permalink":"/documentation/api-tutorial/","summary":"This section assumes that you have already setup your pinia framework project.","tags":[],"title":"API Tutorial"},{"content":"\rAbout Welcome to the official documentation of pionia - /ˌpʌɪəˈnɪə/ framework. Pionia is a PHP Rest Framework that is truly RESTful. It is designed to be simple, lightweight, and easy to use. Pionia is built on top of the Moonlight architecture, which is a powerful architecture for powering highly scaling REST projects. Pionia provides a set of tools and conventions that make it easy to build RESTful APIs in PHP.\nThis framework was born at Service Cops - East Africa by JET and is maintained by the same team. The framework is open-source and is released under the MIT license.\nDocumentation organisation.\nMoonLight Architecture Tutorial Directory Structure Requests Responses Middleware Authentication and Authorization Validation The Controller Services and Actions Database and Querying API Reference Get Started Start with a TO-DO api tutorial\nYou can quickly get started with our To-Do API tutorial. This guide introduces you to the both the framework and the Moonlight architecture. It is the recommended way to start your pionia jungle journey.\nWhy Pionia? There are various reasons why pionia stands out from other PHP frameworks. From program performance, developer performance, to maintainability, pionia has got you covered.\nYou can read more about Why Pionia here.\nInstallation Pre-requisites PHP 8.0 or higher Any web server (Apache, Nginx, etc.) for production Composer Any of Postgres, MySQL, or SQLite Note: This guide assumes you have Composer installed and running globally. If you don\u0026rsquo;t, you can download it from getcomposer.org or use the Composer Docker image.\ncomposer\rGit templates\rcomposer create-project pionia/pionia-app my-project\rRemember to replace my-project with the name of your project.\nSelect use this template on the repository page. Download directly the compressed file from the releases page. Nginx configurationss\nThis is just a sample configuration. You can modify it to suit your needs. But make sure your configuration points to the index.php file of your project.\n# ...rest of your configurations # projet_name [replace this with your project name] location /projet_name { alias /var/www/html/project_name; try_files $uri $uri/ @project_name; } location @project_name { rewrite /project_name/(.*)$ /project_name/index.php?/$1 last; } ## ...rest of your configurations\rContributing Currently the framework is maintained at Service Cops - East Africa but we welcome contributors from all walks of life.\nYou can contribute to the framework, documentation or by helping us grow the community through writing articles, tutorials, and sharing your experience with the framework on any media platform.\nThe framework itself strips off all the unnecessary features that are found in other frameworks and leaves you with only what you need to build a RESTful API. This means you can also contribute by building plugins and extensions that can be used with the framework.\nIf you want to contribute to this documentation, you can find the source code on GitHub.\nPlease read the contributing guidelines before contributing.\nPlease note that this project is released with a Contributor Code of Conduct\n","date":"2024-05-24","id":7,"permalink":"/documentation/introduction/","summary":"About Welcome to the official documentation of pionia - /ˌpʌɪəˈnɪə/ framework.","tags":[],"title":"Introduction"},{"content":"\rHandling Requests Coming soon\u0026hellip;\n","date":"2024-05-24","id":8,"permalink":"/documentation/requests/","summary":"Handling Requests Coming soon\u0026hellip;","tags":[],"title":"Requests"},{"content":"\rThis section assumes that you have a basic understanding of the Pionia framework. If you are new to Pionia, you can start with the tutorial.\nIntroduction Services in Pionia Framework are central holders of business logic. This is where most of the work happens. Pionia has tried to reduce your work from other areas so that you mainly focus on this essential area. Services are in actual PHP code, just php classes that extend the BaseRestService. As you might already know, a class can have multiple methods. In Pionia we cann these Actions. Therefore, henceforth, the terms service and actions will be used for the same meaning throughout the same guide.\nCreating a service You can create a service using our pionia console or manually. All services, as a convention, must be located in the services folder.\nWe recommend to name your services after your database tables. Example, if your table is called \u0026lsquo;users\u0026rsquo;, you can name your service \u0026lsquo;UserService\u0026rsquo;.\nIf you are using our \u0026lsquo;pionia console\u0026rsquo;, then you can just name your service \u0026lsquo;user\u0026rsquo;. These are just conventions!\npionia command\rManually\rLet\u0026rsquo;s create a service called TodoService. In the terminal run the following command.\nphp pionia addservice todo\rBy defualt, running the above command alone create a service called TodoService in services folder with four actions.\ngetTodo - For getting one todo item. listTodo - For getting all available (paginated) todos. deleteTodo - For deleting a todo item. createTodo - For creating a todo item. You can delete or add more actions as you see fit.\nIf you want to override the above behaviour, you can define your actions with the addservice command.\nphp pionia addservice auth login register reset\rThe above will add actions loginAuth, registerAuth and resetAuth.\nNote that everything that is listed after the service name is an action.\nHead over to your services folder. Create a new service with a clear name, such as UserService, AuthService, CartService Extend BaseRestService Add your own actions each taking in data(post request data), files(ff your service is expecting files) and returning BaseResponse. Add your logic Service Registration Creating a service is not enough in Pionia. You also need to register it in our switcher to make it discoverable by the kernel. Service registration happens in the associated switch.\nIn the switches folder, find the switch you want to use for this service. You can add your service as below.\npublic function registerServices(): array { return [ \u0026#39;user\u0026#39; =\u0026gt; new UserService(), \u0026#34;todo\u0026#34; =\u0026gt; new TodoService(), \u0026#39;auth\u0026#39; =\u0026gt; new AuthService(), // like this. ]; }\rThe key of this method is the name you shall use in your proceeding requests to access this service. Therefore it must be unique!\nTargeting a service in the request In the request, you can target a service by determining the SERVICE key with your service name as the key defined in the registerServices method.\n{ SERVICE: \u0026#39;user\u0026#39; // rest of your request data. }\rTargeting a service action To target an action in a certain service, you need to define both the service and action as below.\n{ SERVICE: \u0026#39;user\u0026#39;, ACTION: \u0026#39;loginAuth\u0026#39;, // rest of your service data }\rThe action in every request should match the name of your method in your service action. Pionia uses auto-discovery to automatically call the method passing in every requered data needed for the request.\nAction protection You can protect your actions by determining that they require only authenticated requests(users) to be accessed. You can do this in three ways.\nGlobally At the service level, you can use the $actionsRequiringAuth parameter and add those method names of actions that should be reached by authenticated users only.\nclass TodoService extends BaseRestService { public bool $actionsRequiringAuth = [\u0026#39;getTodo\u0026#39;]; // your other actions here }\rInternally in the action You can also call the mustAuthenticate method anywhere in your action, preferably the first line in the action method.\nclass TodoService extends BaseRestService { // your other actions here protected functon getTodo($data): BaseResponse { $this-\u0026gt;mustAuthenticate() // rest of actions logic } }\r","date":"2024-05-24","id":9,"permalink":"/documentation/services/","summary":"This section assumes that you have a basic understanding of the Pionia framework.","tags":[],"title":"Services"},{"content":"Taking our directory structure from the API Tutorial we created here.\napp ├── switches ├── services ├── authenticationBackends ├── commands ├── middlewares ├── routes.php vendor .gitignore composer.json composer.lock index.php pionia README.md settings.ini\rDirectory Structure Breakdown app:- This is the main directory of the project. It is where all the application logic is stored. It contains the following subdirectories and scripts:\nName Role Type switches The switch is responsible for deciding which service to call based on the registered services. This is where all our service switches are stored. Every switch should be associated with a version of your api. If your api does not need more than one version, one switch is enough. Folder services This is where all our services are stored. This is where you should focus most. All business logic resides here. Folder authenticationBackends This is where we store our authentication backends. Add your authentication backend here and register it in settings.ini Folder middlewares This folder is not included in the initial project setup. But this is where you add your middlewares. Middlewares are used to intercept requests before they reach the switches and after they leave the switches. Folder commands This is where we store our console commands. Add your console commands here. Folder routes.php Our routes behave different, their job is not to not route but to register the switches that should be auto-dicovered. File vendor:- This is where all the dependencies of the project are stored. It is created by composer when you run composer install or composer update.\n.gitignore:- This file is used to tell git which files to ignore when pushing to the repository.\ncomposer.json:- This file is used to manage the dependencies of the project. It is used by composer to install the dependencies.\ncomposer.lock:- This file is used to lock the dependencies of the project. It is used by composer to install the dependencies.\nindex.php:- This is the entry point of the project. It is where the project starts running. This is where you register the middlewares, routes, and authentication backends.\npionia:- This is our console interface. It helps us to run pionia-specific commands.\nREADME.md:- A simple getting started guide for the project.\nsettings.ini:- This is the file that contains the settings of the project. It is where you store the settings of the project.\nAs you can see, pionia maintains the least number of files and directories to make it easy for you to understand and maintain your project. You can always add more directories and files as you see fit. But remember to keep the project as simple as possible.\n","date":"2024-05-24","id":10,"permalink":"/documentation/structure/","summary":"Taking our directory structure from the API Tutorial we created here.","tags":[],"title":"Structure"},{"content":"Pionia all the beautiful parts of Moonlight paradigm. But as the framework, it also has its own unique features. Here are some of the reasons why you should consider using Pionia:\nSimplicity: Pionia is designed to be simple and easy to use. It has a clean and intuitive API that makes it easy to get started with. Remember that boiler plate code you usually have get get after installing most frameworks? Pionia doesn\u0026rsquo;t have even quarter of that. Staff like controllers, routes, models are not here. You just need to write your services and you are good to go. Performance: Pionia is built with performance in mind. It is lightweight and fast, making it ideal for building high-performance api applications. It is also designed to be scalable, so you can easily add more resources as your application grows. You will be surprised how fast your api will be. Api Versioning: Pionia has a unique approach to api versioning. Every switch implies a new version of the api. This means that you can easily add new versions of your api without having to change your existing code. Just roll out a new switch and you are good to go. Security: Pionia has built-in security features that help protect your application from common security threats. It also has a flexible authentication system that allows you to easily integrate with third-party authentication providers. Pionia\u0026rsquo;s authentication especially the authentication backends are inspired by Django and Spring boot authentication system but with less conventions and more customisation. Developer Performance: Using Pionia, rolling out an api should not take even hours. This is achieved by the fact that you don\u0026rsquo;t need to write a lot of boiler plate code. You just need to write your services and you are good to go. Moonlight Compatibility: Pionia follows the standards defined by Moonlight. Advantages like, single endpoint, single request format, single response format, single switch per api version, every request being post and many more\u0026hellip; are all here. Single Request and Response Format: In Pionia projects, all requests carry the same format and all responses too. This makes it easy to understand and work with the api especially on the frontend side. Community: Pionia has a growing community of developers who are passionate about building high-performance api applications. You can find help and support from the community through discord, twitter, and other social media channels. We also take most of the other advantages listed by most other frameworks. Not everything is as you expected in Pionia. We recommend you to first appreciate moonlight before you start using Pionia. This will help you understand the philosophy behind Pionia.\nAlso, please note that Pionia is a RESTful api framework and it intends to keep that way. if you\u0026rsquo;re looking for something else, like a full stack framework, you might want to consider other frameworks like Laravel, Symfony, Yii2, CakePhp, Code Ignitor and others.\n","date":"2024-05-24","id":11,"permalink":"/documentation/why-pionia/","summary":"Pionia all the beautiful parts of Moonlight paradigm. But as the framework, it also has its own unique features.","tags":[],"title":"Why Pionia?"},{"content":"\rThis section assumes you have already set up your project and have already gone through the Api Tutorial guide atleast.\nIntroduction Pionia uses PORM (Pionia ORM) to interact with the database. PORM is a simple and lightweight ORM that is built on top of the medoo framework. PORM provides a set of tools and conventions that make it easy to interact with the database in PHP. PORM is designed to be simple, lightweight, and easy to use.\nInstallation If you want to check out PORM alone or want to use it outside the Pionia framework, you can install it via composer.\ncomposer require pionia/porm\rIf you are using Pionia, you do not need to install PORM separately. PORM is already included in the Pionia framework.\nConfiguration Configuring PORM is simple. All you need is the settings.ini file in the root of your project. The settings.ini file should contain the following:\n[db] database = username = type = host = password = port =\rSee the medoo database configuration for all the available options.\nIf you are using Pionia, you do not need to configure PORM separately. PORM is already configured in the Pionia framework.\nMultiple Database Connections If you want to connect to multiple databases, you can do so by adding the database connection settings to the settings.ini file. You can then specify the database connection to use when querying the database.\n; other settings [db] database = username = type = host = password = port = [db2] database = username = type = host = password = port = ; other settings\rYou can then specify the database connection to use when querying the database.\nuse Porm\\Porm; Porm::from(\u0026#39;posts\u0026#39;)-\u0026gt;using(\u0026#39;db2\u0026#39;); // will connect to the db2 database By default, PORM will use the default database connection(db) to query the database.\nAccessing the Underlying Medoo Instance If you need to access the underlying Medoo instance, you can do so by calling the getDatabase method on the Porm class.\nuse Porm\\Porm; $instance = Porm::from(\u0026#39;posts\u0026#39;); //other queries here $database = $instance-\u0026gt;database; // returns the Medoo instance // this is also similar to $database = $instance-\u0026gt;getDatabase(); // returns the Medoo instance The $database variable will contain the Medoo instance, which you can use to interact with the database directly availing every method medoo provides.\nGetting the last inserted ID To get the last inserted ID after inserting a record into the database, you can call the lastId method on the Porm class.\nuse Porm\\Porm; $instance = Porm::from(\u0026#39;posts\u0026#39;) -\u0026gt;save([ \u0026#39;title\u0026#39; =\u0026gt; \u0026#39;My Post\u0026#39;, \u0026#39;content\u0026#39; =\u0026gt; \u0026#39;This is my post content\u0026#39; ]); // other queries here $lastId = $instance-\u0026gt;lastId();\rThe $lastId variable will contain the last inserted ID.\nUsage PORM does not rely on models to interact with the database. Instead, you get to interact with the database directly. This comes with a lot of flexibility and simplicity. Porm also interacts with both new and existing databases.\nAll Queries originate from the Porm instance. Here is an example of how to interact with the database using PORM.\nDetermining the target table All queries start by determining the target table. This is done by calling the from method on the Porm instance. The from method takes the table name as the first argument. The table name must match the table name in the database.\nuse Porm\\Porm; Porm::from(\u0026#39;posts\u0026#39;);\rYou can also alias the table name by passing the alias as the second argument.\nuse Porm\\Porm; Porm::from(\u0026#39;posts\u0026#39;, \u0026#39;p\u0026#39;);\rAs of v1.0.2, You can achieve the above using the table method. This method is exactly the same as the from method however it is more readable.\nuse Porm\\Porm; Porm::table(\u0026#39;posts\u0026#39;, \u0026#39;p\u0026#39;);\rYou can also define the connection to use at this point.\nuse Porm\\Porm; # will connect to the db2 database Porm::from(\u0026#39;posts\u0026#39;, \u0026#39;p\u0026#39;, \u0026#39;db2\u0026#39;); # or Porm::table(\u0026#39;posts\u0026#39;, \u0026#39;p\u0026#39;, \u0026#39;db2\u0026#39;);\rDefining the columns To select specific columns from the table, you can use the columns method. This method should be called on the Porm instance.\nuse Porm\\Porm; Porm::from(\u0026#39;posts\u0026#39;)-\u0026gt;columns(\u0026#39;id\u0026#39;, \u0026#39;title\u0026#39;); # or Porm::table(\u0026#39;posts\u0026#39;)-\u0026gt;columns([\u0026#39;id\u0026#39;, \u0026#39;title\u0026#39;]);\rThis can used whether getting one or multiple records.\n","date":"0001-01-01","id":12,"permalink":"/documentation/database/configuration-getting-started/","summary":"This section assumes you have already set up your project and have already gone through the Api Tutorial guide atleast.","tags":[],"title":"Configuration - Getting Started"},{"content":"\rThis section assumes you have already set up your project and have already gone through the Api Tutorial guide atleast.\nIntroduction. Pionia uses PORM (Pionia ORM) to interact with the database. PORM is a simple and lightweight ORM that is built on top of the medoo framework. PORM provides a set of tools and conventions that make it easy to interact with the database in PHP. PORM is designed to be simple, lightweight, and easy to use.\nInstallation If you want to check out PORM alone or want to use it outside the Pionia framework, you can install it via composer.\ncomposer require pionia/porm\rIf you are using Pionia, you do not need to install PORM separately. PORM is already included in the Pionia framework.\nConfiguration Configuring PORM is simple. All you need is the settings.ini file in the root of your project. The settings.ini file should contain the following:\n[db] database = username = type = host = password = port =\rSee the medoo database configuration for all the available options.\nIf you are using Pionia, you do not need to configure PORM separately. PORM is already configured in the Pionia framework.\nMultiple Database Connections If you want to connect to multiple databases, you can do so by adding the database connection settings to the settings.ini file. You can then specify the database connection to use when querying the database.\n; other settings [db] database = username = type = host = password = port = [db2] database = username = type = host = password = port = ; other settings\rYou can then specify the database connection to use when querying the database.\nuse Porm\\Porm; Porm::from(\u0026#39;posts\u0026#39;)-\u0026gt;using(\u0026#39;db2\u0026#39;); // will connect to the db2 database By default, PORM will use the default database connection(db) to query the database.\n","date":"0001-01-01","id":13,"permalink":"/docs/documentation/database/","summary":"This section assumes you have already set up your project and have already gone through the Api Tutorial guide atleast.","tags":[],"title":"Database"},{"content":"\rThis section assumes you have alredy completed configuring the database from the Configuration Section.\nIntroduction Under this section, we will look at how to make queries to the database using the PORM - Pionia ORM. Queries are used to interact with the database and retrieve data. PORM provides a set of tools and conventions that make it easy to interact with the database in PHP.\nRetrieving Data You can retrieve a single item from the database or multiple items at ago. In Porm, not all methods query the database. Some methods are used to build the query and return the query object.\nRetrieving a Single Item To retrieve a single item from the database, you can use the get method. This method returns an object or NULL if no matching record is found.\nuse Porm\\Porm; Porm::from(\u0026#39;users\u0026#39;)-\u0026gt;get(1); // select * from users where id = 1 If the an integer or string is provided for the get method, it is assumed to be the primary key of the table. If an array is provided, it is assumed to be the where clause.\nYou can also provide an integer or string and determine the column name to use as the primary key.\nuse Porm\\Porm; Porm::from(\u0026#39;users\u0026#39;)-\u0026gt;get(1, \u0026#39;user_id\u0026#39;); // select * from users where user_id = 1 Conditions can also be provided as an array. The array should contain the column name as the key and the value as the value. This is one way of building a where clause.\nuse Porm\\Porm; $data = Porm::from(\u0026#39;users\u0026#39;)-\u0026gt;get([\u0026#39;user_id\u0026#39; =\u0026gt; 1, \u0026#39;age\u0026#39; =\u0026gt; 10]); // select * from users where user_id = 1 and age = 10 All array conditions passed to the get method are joined by AND.\n$data will contain the object or NULL if no matching record is found.\nThe get method queries the database. So you should always call the get method last.\nFetching multiple records To fetch all data from the table, you can use the all method. This method, just like the get method, can take up array conditions and also queries the database. Therefore, you should always call the all method last.\nuse Porm\\Porm; $data = Porm::from(\u0026#39;posts\u0026#39;)-\u0026gt;all(); var_dump($data); // array of data You can also specify the columns to fetch by using the columns method. This is useful when you only need specific columns from the table and can be used before all methods that query the database.\nuse Porm\\Porm; $data = Porm::from(\u0026#39;posts\u0026#39;)-\u0026gt;columns(\u0026#39;id\u0026#39;, \u0026#39;title\u0026#39;)-\u0026gt;all(); var_dump($data); // array of data You can filter the data by providing the array of conditions to the all method just like we did with the get method.\nuse Porm\\Porm; $data = Porm::from(\u0026#39;posts\u0026#39;)-\u0026gt;all([\u0026#39;id\u0026#39; =\u0026gt; 1]); // select * from posts where id = 1 var_dump($data); // array of data The all method unlike the get method, returns an array of data or an empty array if no matching record is found.\nRandom Records To get random data from the table, you can use the random method. The random method takes the number of results to return as the first argument.\nuse Porm\\Porm; $data = Porm::from(\u0026#39;posts\u0026#39;)-\u0026gt;random(10); var_dump($data); // array of data You can also pass an array of conditions to the random method.\nuse Porm\\Porm; $data = Porm::from(\u0026#39;posts\u0026#39;)-\u0026gt;random(10, [\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;Pionia\u0026#39;]); var_dump($data); // array of data To get just one random item, you can pass 1 or ignore the length.\nuse Porm\\Porm; $data = Porm::from(\u0026#39;posts\u0026#39;)-\u0026gt;random(); var_dump($data); // object of data The random method queries the database. So you should always call the random method last. Also, if you query one item, random will return an object, but if you define length greater than one, it will return an array.\nInserting Data To insert data into the table, you can use the save method. The save method takes an array of data to insert into the table and returns the saved object.\nuse Porm\\Porm; $data = Porm::from(\u0026#39;posts\u0026#39;)-\u0026gt;save([\u0026#39;title\u0026#39; =\u0026gt; \u0026#39;Hello\u0026#39;, \u0026#39;content\u0026#39; =\u0026gt; \u0026#39;World\u0026#39;]); var_dump($data); // the saved object The save method hits the database. So you should always call the save method last.\nUpdating Data To update data in the table, you can use the update method. The update method takes an array of data to update in the table and the condition to filter the data on.\nThis method returns a PDOStatement object. You can get the number of rows affected by calling the rowCount method on the returned object.\nuse Porm\\Porm; $data = Porm::from(\u0026#39;posts\u0026#39;) -\u0026gt;update([\u0026#39;title\u0026#39; =\u0026gt; \u0026#39;Hello\u0026#39;, \u0026#39;content\u0026#39; =\u0026gt; \u0026#39;World\u0026#39;], [\u0026#39;id\u0026#39; =\u0026gt; 1]); // update posts set title = \u0026#39;Hello\u0026#39;, content = \u0026#39;World\u0026#39; where id = 1 var_dump($data-\u0026gt;rowCount()); // the number of rows affected The update method hits the database. So you should always call the update method last.\nDeleting Data To delete data from the table, you can use the delete method. The delete method takes the condition to filter the data on.\nThis method returns a PDOStatement object. You can get the number of rows affected by calling the rowCount method on the returned object.\nuse Porm\\Porm; $data = Porm::from(\u0026#39;posts\u0026#39;)-\u0026gt;delete([\u0026#39;id\u0026#39; =\u0026gt; 1]); var_dump($data-\u0026gt;rowCount()); // the number of rows affected This method can also be used to delete all data from the table that matches the condition. Passing an empty array will delete all data from the table.\nuse Porm\\Porm; $data = Porm::from(\u0026#39;posts\u0026#39;)-\u0026gt;deleteAll([]); var_dump($data-\u0026gt;rowCount()); // the number of rows affected The two methods delete and deleteAll do exactly the same thing. deleteAll is just an alias for delete.\nYou can also delete data based on the primary key id.\nuse Porm\\Porm; $id = 2 $data = Porm::from(\u0026#39;posts\u0026#39;)-\u0026gt;deleteById($id); // delete from posts where id = 2 var_dump($data-\u0026gt;rowCount());\rHas Data To check if data exists in the table, you can use the has method. The has method takes the condition to filter the data on.\nThis method returns a boolean value.\nuse Porm\\Porm; $data = Porm::from(\u0026#39;posts\u0026#39;)-\u0026gt;has([\u0026#39;id\u0026#39; =\u0026gt; 1]); var_dump($data); // true or false The has method queries the database. So you should always call the has method last.\nPassing a string to has queries the database for the primary key id.\nuse Porm\\Porm; $id = \u0026#39;123\u0026#39; $data = Porm::from(\u0026#39;posts\u0026#39;)-\u0026gt;has($id); var_dump($data); // true or false ","date":"0001-01-01","id":14,"permalink":"/documentation/database/making-queries/","summary":"This section assumes you have alredy completed configuring the database from the Configuration Section.","tags":[],"title":"Making Queries"},{"content":"\rThis section assumes you have alredy completed configuring the database from the Configuration Section.\nAlso, for basic knowledge and understanding, please first look at the Making Queries Section\nIntroduction Sometimes, you need more than just fetching data from the database. You may need to filter the data based on certain conditions. This is where filtering comes in. Filtering allows you to specify conditions that the data must meet before it is returned.\nIn this section, we will look at how to filter data when querying the database using PORM.\nShortcuts Introduction Shortcuts where filter Where Builder Bulding AND Conditions OR Conditions AND and OR Complex Relativity where This method can be used to filter data based on a single \u0026lsquo;AND\u0026rsquo; condition. This method can be used with all the other methods in the query builder.\n$users = Porm::from(\u0026#39;users\u0026#39;)-\u0026gt;where([\u0026#39;age\u0026#39; =\u0026gt; 10])-\u0026gt;get();\rYou can chain as many where methods as you want to filter the data.\n$users = Porm::from(\u0026#39;users\u0026#39;) -\u0026gt;where([\u0026#39;age\u0026#39; =\u0026gt; 10]) -\u0026gt;where([\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;John Doe\u0026#39;]) -\u0026gt;all();\rAll conditions in the where method are joined by an \u0026lsquo;AND\u0026rsquo; operator.\nfilter The filter method can be used to filter data based on multiple conditions. The conditions are joined by an \u0026lsquo;AND\u0026rsquo; operator.\n$users = Porm::from(\u0026#39;users\u0026#39;) -\u0026gt;filter([\u0026#39;age\u0026#39; =\u0026gt; 10, \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;John Doe\u0026#39;]) -\u0026gt;all();\rThis might look familiar, however, the filter method ports us to the underlying QueryBuilder class, which allows us to chain more complex conditions and avails more methods.\nUsing filter, you can access methods such as orderBy, group, limit, match, having, first, get, all and many more.\n$users = Porm::from(\u0026#39;users\u0026#39;) -\u0026gt;filter([\u0026#39;age\u0026#39; =\u0026gt; 10, \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;John Doe\u0026#39;]) -\u0026gt;orderBy([\u0026#39;age\u0026#39; =\u0026gt; \u0026#39;DESC\u0026#39;]) -\u0026gt;limit(10) -\u0026gt;startAt(5) -\u0026gt;all();\rWhere Builder Observing all our examples provided so far, we can notice that where conditions are passed as an array. With this builder, you can build a more complex query which will internally be converted to an array as shown in the examples above.\nBulding To start building, you need to first call the builder method on the Where class.\n$clause= Where::builder();\rFrom there, you can chain methods to build your query.\nThe builder MUST finally call the build method to actually build the query.\n$clause = Where::builder() // add here both AND and OR conditions -\u0026gt;build();\rYou can then pass this clause to any method that accepts conditions.\n$clause = Where::builder() // add here both AND and OR conditions -\u0026gt;build(); $users = Porm::from(\u0026#39;users\u0026#39;) -\u0026gt;where($clause) // with where method -\u0026gt;all(); $users = Porm::from(\u0026#39;users\u0026#39;) -\u0026gt;filter($clause) // with filter method -\u0026gt;all(); $users = Porm::from(\u0026#39;users\u0026#39;) -\u0026gt;all($clause); // with all method $users = Porm::from(\u0026#39;users\u0026#39;) -\u0026gt;first($clause); // with first method $users = Porm::from(\u0026#39;users\u0026#39;) -\u0026gt;filter($clause) // with filter method that also defines more complex queries -\u0026gt;orderBy([\u0026#39;age\u0026#39; =\u0026gt; \u0026#39;DESC\u0026#39;]) -\u0026gt;limit(10) -\u0026gt;startAt(5) -\u0026gt;all();\rAND Conditions To add an \u0026lsquo;AND\u0026rsquo; condition, you can use the and method.\n$clause = Where::builder() -\u0026gt;and([\u0026#39;age\u0026#39; =\u0026gt; 10]) -\u0026gt;and([\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;John Doe\u0026#39;]) -\u0026gt;build();\rYou can chain as many and methods as you want to add more conditions.\nOR Conditions To add an \u0026lsquo;OR\u0026rsquo; condition, you can use the or method.\n$clause = Where::builder() -\u0026gt;or([\u0026#39;age\u0026#39; =\u0026gt; 10]) -\u0026gt;or([\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;John Doe\u0026#39;]) -\u0026gt;build();\rYou can chain as many or methods as you want to add more conditions.\nThe \u0026ldquo;and()\u0026rdquo; and \u0026ldquo;or()\u0026rdquo; methods can be used together to build more complex queries.\nAlso note that the \u0026ldquo;and()\u0026rdquo; and \u0026ldquo;or()\u0026rdquo; methods take in an array of conditions. Which means you can pass a full clause to them too!\nThis is how you start to build more complex conditions!\nAND and OR You can mix \u0026lsquo;AND\u0026rsquo; and \u0026lsquo;OR\u0026rsquo; conditions to build more complex queries.\n$clause = Where::builder() -\u0026gt;and([\u0026#39;age\u0026#39; =\u0026gt; 10]) -\u0026gt;or([\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;John Doe\u0026#39;]) -\u0026gt;build();\rYou can chain as many and and or methods as you want to build more complex queries.\nComplex Relativity You can also build more complex queries by nesting conditions.\n$clause = Where::builder() -\u0026gt;and([\u0026#39;age\u0026#39; =\u0026gt; 10]) -\u0026gt;or( Where::builder() -\u0026gt;and([\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;John Doe\u0026#39;]) -\u0026gt;or([\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;Jane Doe\u0026#39;]) -\u0026gt;and([\u0026#39;age\u0026#39; =\u0026gt; 20]) -\u0026gt;build() ) -\u0026gt;build(); // where age = 10 OR (name = \u0026#39;John Doe\u0026#39; OR name = \u0026#39;Jane Doe\u0026#39; AND age = 20) You can nest as many conditions as you want to build more complex queries. This is where Porm shines!\n","date":"0001-01-01","id":15,"permalink":"/documentation/database/queries-with-filtering/","summary":"This section assumes you have alredy completed configuring the database from the Configuration Section.","tags":[],"title":"Queries with Filtering"},{"content":"\rThis section assumes you have alredy completed configuring the database from the Configuration Section.\nAlso, for basic knowledge and understanding, please first look at the Making Queries Section\nIntroduction This section convers database functions that can be used to aggregate data in the database. Aggregation functions are used to perform calculations on the data in the database. These functions can be used to calculate the sum, average, minimum, maximum, and count of the data in the database.\nShortcuts Introduction Shortcuts Inbuilt Aggregation Functions count sum avg max min Using the Agg Builder Initializing the Agg Builder random avg compare like notLike div between notBetween jsonified of minus plus eq neq now lt lte gt gte uuid max() min() sum() regex Chaining multiple Inbuilt Aggregation Functions Some common aggregation functions have already been implemented in PORM. These functions can be used to perform calculations on the data in the database directly.\ncount The count function is used to count the number of records in the database. This function can be used to count the number of records in the database that meet certain conditions.\nuse Porm\\Porm; Porm::from(\u0026#39;users\u0026#39;)-\u0026gt;count(); // select count(*) from users You can also provide a column name to count the number of records in the database that have a value in the specified column.\nuse Porm\\Porm; Porm::from(\u0026#39;users\u0026#39;)-\u0026gt;count(\u0026#39;age\u0026#39;); // select count(age) from users You can also provide conditions to count the number of records in the database that meet certain conditions.\nuse Porm\\Porm; Porm::from(\u0026#39;users\u0026#39;)-\u0026gt;count(\u0026#39;age\u0026#39;, [\u0026#39;age\u0026#39; =\u0026gt; 10]); // select count(*) from users where age = 10 The count function returns the number of records in the database that meet the specified conditions.\nsum The sum function is used to calculate the sum of the values in a column in the database. This function can be used to calculate the sum of the values in a column in the database that meet certain conditions.\nuse Porm\\Porm; Porm::from(\u0026#39;users\u0026#39;)-\u0026gt;sum(\u0026#39;age\u0026#39;); // select sum(age) from users You can also provide conditions to calculate the sum of the values in a column in the database that meet certain conditions.\nuse Porm\\Porm; Porm::from(\u0026#39;users\u0026#39;)-\u0026gt;sum(\u0026#39;age\u0026#39;, [\u0026#39;age\u0026#39; =\u0026gt; 10]); // select sum(age) from users where age = 10 The sum function returns the sum of the values in the column in the database that meet the specified conditions.\nAll methods that take in a condition can be called after the \u0026ldquo;where\u0026rdquo; method. This is because the \u0026ldquo;where\u0026rdquo; method is used to build the where clause for the query.\navg The avg function is used to calculate the average of the values in a column in the database. This function can be used to calculate the average of the values in a column in the database that meet certain conditions.\nuse Porm\\Porm; Porm::from(\u0026#39;users\u0026#39;)-\u0026gt;avg(\u0026#39;age\u0026#39;); // select avg(age) from users You can also provide conditions to calculate the average of the values in a column in the database that meet certain conditions.\nuse Porm\\Porm; Porm::from(\u0026#39;users\u0026#39;)-\u0026gt;avg(\u0026#39;age\u0026#39;, [\u0026#39;age\u0026#39; =\u0026gt; 10]); // select avg(age) from users where age = 10 The avg function returns the average of the values in the column in the database that meet the specified conditions.\nmax The max function is used to calculate the maximum value in a column in the database. This function can be used to calculate the maximum value in a column in the database that meet certain conditions.\nuse Porm\\Porm; Porm::from(\u0026#39;users\u0026#39;)-\u0026gt;max(\u0026#39;age\u0026#39;); // select max(age) from users You can also provide conditions to calculate the maximum value in a column in the database that meet certain conditions.\nuse Porm\\Porm; Porm::from(\u0026#39;users\u0026#39;)-\u0026gt;max(\u0026#39;age\u0026#39;, [\u0026#39;age\u0026#39; =\u0026gt; 10]); // select max(age) from users where age = 10 The max function returns the maximum value in the column in the database that meet the specified conditions.\nmin The min function is used to calculate the minimum value in a column in the database. This function can be used to calculate the minimum value in a column in the database that meet certain conditions.\nuse Porm\\Porm; Porm::from(\u0026#39;users\u0026#39;)-\u0026gt;min(\u0026#39;age\u0026#39;); // select min(age) from users You can also provide conditions to calculate the minimum value in a column in the database that meet certain conditions.\nuse Porm\\Porm; Porm::from(\u0026#39;users\u0026#39;)-\u0026gt;min(\u0026#39;age\u0026#39;, [\u0026#39;age\u0026#39; =\u0026gt; 10]); // select min(age) from users where age = 10 The min function returns the minimum value in the column in the database that meet the specified conditions.\nAll the above methods query the database and return the result. Therefore, you should always call these methods last.\nUsing the Agg Builder We have also put aside a builder class that can be used to build more complex aggregation queries. The Agg builder comes with a number of methods to cover your aggregation needs.\nInitializing the Agg Builder To initialize the Agg builder, you can use the builder method.\nYou must finally call the build method to get the actually build your generated aggregates.\nuse Porm\\database\\aggregation\\Agg; $agg = Agg::builder() // add here your aggregation functions -\u0026gt;build();\rAgg builder comes with a number of methods that can be used to build the aggregation query. They include\nrandom use Porm\\database\\aggregation\\Agg; $agg = Agg::builder() -\u0026gt;random(\u0026#39;name\u0026#39;, \u0026#39;names\u0026#39;) // rand(names) as names -\u0026gt;build();\ravg use Porm\\database\\aggregation\\Agg; $agg = Agg::builder() -\u0026gt;avg(\u0026#39;age\u0026#39;, \u0026#39;average_age\u0026#39;) // avg(age) as average_age -\u0026gt;build();\rcompare Compare the value of two columns in the database. In comparison we use operators like =, \u0026gt;, \u0026lt;, !=.\nuse Porm\\database\\aggregation\\Agg; $agg = Agg::builder() -\u0026gt;columnsCompare(\u0026#39;price\u0026#39;, \u0026#39;\u0026gt;\u0026#39;, \u0026#39;10\u0026#39;) // age \u0026gt; 10 -\u0026gt;build();\rlike Used to add a like condition to a query\n$user = Porm::from(\u0026#34;todos\u0026#34;) -\u0026gt;get(Agg::builder() -\u0026gt;like(\u0026#39;title\u0026#39;, $name) -\u0026gt;build() ); // select * from todos where title like \u0026#39;%$name%\u0026#39; notLike Used to add a not like condition to a query\n$user = Porm::from(\u0026#34;todos\u0026#34;) -\u0026gt;get(Agg::builder() -\u0026gt;notLike(\u0026#39;title\u0026#39;, $name) -\u0026gt;build() ); // select * from todos where title not like \u0026#39;%$name%\u0026#39; div Used to divide a column by a certain value in the database\n$user = Porm::from(\u0026#34;todos\u0026#34;) -\u0026gt;get(Agg::builder() -\u0026gt;div(\u0026#39;total\u0026#39;, 5) -\u0026gt;build() ); // select total/5 from todos between Adds a between check on a column. It checks if the value of the given column is between two given points.\n$results = Porm::from(\u0026#34;todos\u0026#34;) -\u0026gt;where(Agg::builder() -\u0026gt;between(\u0026#39;id\u0026#39;, [1, 10]) -\u0026gt;build() )-\u0026gt;all(); // select * from todos where id between 1 and 10 notBetween Checks if the value of the given column is not between the given points.\n$results = Porm::from(\u0026#34;todos\u0026#34;) -\u0026gt;where(Agg::builder() -\u0026gt;notBetween(\u0026#39;id\u0026#39;, [1, 10]) -\u0026gt;build() )-\u0026gt;all();\rjsonified Jsonify the given value and assigns it to the given column.\nPorm::from(\u0026#34;todos\u0026#34;) -\u0026gt;filter(Agg::builder() -\u0026gt;jsonified(\u0026#39;someAlias\u0026#39;, [\u0026#39;x\u0026#39;=\u0026gt;1, \u0026#39;y\u0026#39;=\u0026gt;5]) -\u0026gt;build() )-\u0026gt;all(); // select JSON(\u0026#39;x\u0026#39;, 1, \u0026#39;y\u0026#39;, 5) as someAlias from todos of Multiplies a column by a certain value in the database\nPorm::from(\u0026#34;todos\u0026#34;) -\u0026gt;filter(Agg::builder() -\u0026gt;of(\u0026#39;age\u0026#39;, 10) -\u0026gt;build() )-\u0026gt;all(); // select someAlias*10 from todos minus Subtracts a column by a certain value in the database\nPorm::from(\u0026#34;todos\u0026#34;) -\u0026gt;filter(Agg::builder() -\u0026gt;minus(\u0026#39;age\u0026#39;, 10) -\u0026gt;build() )-\u0026gt;all(); // select someAlias-10 from todos plus Adds a column by a certain value in the database\nPorm::from(\u0026#34;todos\u0026#34;) -\u0026gt;filter(Agg::builder() -\u0026gt;plus(\u0026#39;age\u0026#39;, 10) -\u0026gt;build() )-\u0026gt;all(); // select someAlias+10 from todos eq Opposite of eq. Checks if the value of the given column is equal to the given value.\nPorm::from(\u0026#34;todos\u0026#34;) -\u0026gt;filter(Agg::builder() -\u0026gt;eq(\u0026#39;age\u0026#39;, 10) -\u0026gt;build() )-\u0026gt;all(); // select someAlias=10 from todos neq Opposite of eq. Checks if the value of the given is not equal to the given value.\nPorm::from(\u0026#34;todos\u0026#34;) -\u0026gt;filter(Agg::builder() -\u0026gt;neq(\u0026#39;age\u0026#39;, 10) -\u0026gt;build() )-\u0026gt;all(); // select someAlias!=10 from todos now Assigns the current timestamp to the given alias or column.\nPorm::from(\u0026#34;todos\u0026#34;) -\u0026gt;update(Agg::builder()-\u0026gt;now(\u0026#34;updated_at\u0026#34;)-\u0026gt;build(), 1); // update todos set updated_at = now() where id =1 lt Check if the column value is less than the given value.\nPorm::from(\u0026#34;todos\u0026#34;) -\u0026gt;where(Agg::builder()-\u0026gt;lt(\u0026#39;age\u0026#39;, 20)-\u0026gt;build()) -\u0026gt;all();\rlte Checks if the column value is less than or equal to the given value.\nPorm::from(\u0026#34;todos\u0026#34;) -\u0026gt;where(Agg::builder()-\u0026gt;lte(\u0026#39;age\u0026#39;, 20)-\u0026gt;build()) -\u0026gt;all();\rgt Checks if the column value is greater than the given value.\nPorm::from(\u0026#34;todos\u0026#34;) -\u0026gt;where(Agg::builder()-\u0026gt;gt(\u0026#39;age\u0026#39;, 20)-\u0026gt;build()) -\u0026gt;all();\rgte Checks if the column value is greater than or equal the given value.\nPorm::from(\u0026#34;todos\u0026#34;) -\u0026gt;where(Agg::builder()-\u0026gt;gte(\u0026#39;age\u0026#39;, 20)-\u0026gt;build()) -\u0026gt;all();\ruuid This can be used in two ways. The first way is where a uuid is provided and the other way is where you want to sign a unique random uuid to a column.\n$agg = Agg::builder()-\u0026gt;uuid(\u0026#39;code\u0026#39;)-\u0026gt;build() // code = uuid() // or with an existing one. $agg = Agg::builder()-\u0026gt;uuid(\u0026#39;code\u0026#39;, $myCoolUuid)-\u0026gt;build() // code = \u0026#39;$myCoolUuid\u0026#39; max() Gets the maximum value of the given column and assigns it to the given alias\n$agg = Agg::builder()-\u0026gt;max(\u0026#39;maxAge\u0026#39;, \u0026#39;age\u0026#39;)-\u0026gt;build() // MAX(age) as maxAge min() Gets the minimum value of the given column and assigns it to the given alias\n$agg = Agg::builder()-\u0026gt;min(\u0026#39;maxAge\u0026#39;, \u0026#39;age\u0026#39;)-\u0026gt;build() // MIN(age) as maxAge sum() Gets the sum of the given column and assigns it to the given alias.\n$agg = Agg::builder()-\u0026gt;sum(\u0026#39;maxAge\u0026#39;, \u0026#39;age\u0026#39;)-\u0026gt;build() // SUM(age) as maxAge regex If all above don\u0026rsquo;t work for you, you can use this aggregation function to provide your own regular expression that the db should check against.\n$agg = Agg::builder()-\u0026gt;regex(\u0026#39;name\u0026#39;, \u0026#39;^d\u0026#39;)-\u0026gt;build() // name ~ \u0026#39;^d\u0026#39; Chaining multiple You can chain as many aggregations as you with till you call the build() method.\n$agg = Agg::builder() -\u0026gt;regex(\u0026#39;name\u0026#39;, \u0026#39;^d\u0026#39;) -\u0026gt;gte(\u0026#39;age\u0026#39;, 10) -\u0026gt;build(); // name ~ \u0026#39;^d\u0026#39; and age \u0026gt;= 10 ","date":"0001-01-01","id":16,"permalink":"/documentation/database/using-functions-aggregation/","summary":"This section assumes you have alredy completed configuring the database from the Configuration Section.","tags":[],"title":"Using Functions - Aggregation"},{"content":"","date":"2023-09-07","id":17,"permalink":"/docs/reference/","summary":"","tags":[],"title":"Reference"},{"content":"Reference pages are ideal for outlining how things work in terse and clear terms. Less concerned with telling a story or addressing a specific use case, they should give a comprehensive outline of what your documenting.\nFurther reading Read about reference in the Diátaxis framework ","date":"2023-09-07","id":18,"permalink":"/reference/example-reference/","summary":"Reference pages are ideal for outlining how things work in terse and clear terms.","tags":[],"title":"Example Reference"},{"content":"We shall be updating this page with resources that will help you enhance your Pionia Framework journey.\n","date":"2024-02-27","id":19,"permalink":"/resources/","summary":"We shall be updating this page with resources that will help you enhance your Pionia Framework journey.","tags":[],"title":"Resources"},{"content":"","date":"2023-09-07","id":20,"permalink":"/docs/","summary":"","tags":[],"title":"Docs"},{"content":"Privacy Policy ","date":"2023-09-07","id":21,"permalink":"/privacy/","summary":"Privacy Policy ","tags":[],"title":"Privacy Policy"},{"content":"\rcomposer create-project pionia/pionia-app my_beautiful_project #replace my_beautiful_project with your project name\rPionia Framework Pionia is the first PHP Rest Framework that is truly RESTful. It is designed to be simple, lightweight, and easy to use. Pionia is built on top of the Moonlight architecture, which is a powerful architecture for powering highly scaling REST projects. Pionia provides a set of tools and conventions that make it easy to build RESTful APIs in PHP.\nWhy Pionia? ","date":"2023-09-07","id":22,"permalink":"/","summary":"composer create-project pionia/pionia-app my_beautiful_project #replace my_beautiful_project with your project name\rPionia Framework Pionia is the first PHP Rest Framework that is truly RESTful.","tags":[],"title":"Pionia Framework"},{"content":"","date":"0001-01-01","id":23,"permalink":"/categories/","summary":"","tags":[],"title":"Categories"},{"content":"","date":"0001-01-01","id":24,"permalink":"/contributors/","summary":"","tags":[],"title":"Contributors"},{"content":"","date":"0001-01-01","id":25,"permalink":"/tags/","summary":"","tags":[],"title":"Tags"}]