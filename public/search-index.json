[{"content":"Well-thought-through product announcements will help increase feature awareness and engage users with new functionality. Just like sharing your public roadmap, it\u0026rsquo;s also a great way to let potential customers see that you\u0026rsquo;re constantly improving.\nFurther reading Read How to announce product updates and features ","date":"2023-09-07","id":0,"permalink":"/blog/example-post/","summary":"You can use blog posts for announcing product updates and features.","tags":[],"title":"Example Post"},{"content":"","date":"2023-09-07","id":1,"permalink":"/blog/","summary":"","tags":[],"title":"Blog"},{"content":"MoonLight is a rather new architecture that is based on the commonly used architectures of gRPC, MVC(Model View Controller), Micro-Services and Monolothic. It picks the best of all these architectures and combines them to create a new architecture that is more efficient and scalable.\nThe MoonLight paradigm Below are the new conventions that MoonLight architecture brings to the table:\nArchitecture Overview\nThe car scenario! \u0026ndash; 1\nImagine a scenario of a car, the car can have passengers and multiple passengers. The job of the driver is to controll the rest of the car, and the passengers to behave themselves and not interfere with the driver. The driver has one steering wheel in the entire car. Some cars may have a conductor who is responsible for the passengers instead of the driver. This helps the driver to focus on the road and not the passengers.\nThe traffic scenario! \u0026ndash; 2\nBased on the scenario above, the driver is stopped by the traffic police man, the polica man moves to the driver\u0026rsquo;s side and not the passengers side. The police man looks through the driver\u0026rsquo;s window and checks if there are any issues with the passengers. He asks the first passenger to pass over their id, the passenger forwards the id to the driver who then hands it over to the police. He checks and gives it to the driver who then hands it over to the passenger.\nNOTE Remember the above scenarios as we dive into the MoonLight architecture\n1. Single API endpoint/route In the moonlight, all requests target the same endpoint. This is to ensure that the application is scalable and easy to maintain. This also makes it easier to debug and monitor the application.\nAssuming the application is running on http://localhost:3000, all requests will be made to http://localhost:3000/api/v1/. This is the only endpoint that is exposed to the outside world.\nOn top of other advantages, now frontend devs don\u0026rsquo;t have to worry about the base URL of the API. They can just make requests to the /api/v1/ endpoint and the application will handle the rest.\nPoint To Ponder!\nThis is our drivers window in the car scenario.\nFor anyone to interact with the application, they must go through this endpoint only.\n2. POST Requests only All requests under moonlight architecture are made using the http method of POST only. This is to ensure that the requests are secure and the data is not exposed in the URL. Also, the application gets to benefit highly from ssl encryption and other security features that are available for POST requests.\n3. Single Request Format In Moonlight architecture, all requests are made in a similar format. This makes it easier to understand and debug the requests. Requests can either be be of type JSON or form-data.\nEvery request must define the SERVICE and ACTION to exacute in the request body plus the rest rest of the payload as required by the service.\nPOST http://localhost:3000/api/v1/\r{ \u0026#34;SERVICE\u0026#34;: \u0026#34;users\u0026#34;, \u0026#34;ACTION\u0026#34;: \u0026#34;get_user_by_profile\u0026#34;, \u0026#34;profile\u0026#34;: \u0026#34;@1233232\u0026#34; }\rThe SERVICE and ACTION are required in every request. The rest of the payload is dependent on the service and action being executed.\nPoint To Ponder!\nThis architecture, if to be well implemented must follow the Object Oriented Programming paradigm. With this, services should/must be classes or interfaces(golang) that combine together related business logic like AuthenticationService, ProductService, OrderService etc.\nAnd Actions should be methods in these classes like login, register in the AuthenticationService class.\n4. Single Response Format This architecture also calls for a single response format. This makes it way easier to understand and debug the responses. The response format is as follows:\nResponse\r{ \u0026#34;statusCode\u0026#34;: 0, \u0026#34;returnMessage\u0026#34;: \u0026#34;Some cool message here or null\u0026#34;, \u0026#34;returnData\u0026#34;: \u0026#34;the data you\u0026#39;re sending to the frontend\u0026#34;, \u0026#34;extraData\u0026#34;: \u0026#34;any extra data you want to send to the frontend\u0026#34; }\rWith statusCode, it implies that the developer/business can define their own custom status codes. However, by convention, a status code of 0 implies success and is recommended to be kept for the same.\n5. HTTP 200 OK for all. All requests in this architecture that reach the application server should/must return an http status of 200 OK. The only special case is 502 Gateway Error which is returned when the application server is down or unreachable.\nPoint To Ponder!\nThink about it, the application server actually handled your request so whether the request raised an exception or successfully executed, the server actually handled. And that\u0026rsquo;s what we are actually looking for.\nRemember the traffic scenario!\nEvery time our police man poses a question, he expects an answer. If the driver doesn\u0026rsquo;t have an answer, he should say so(which is also an answer) and not just keep quiet.\n6. Single Controller Per Application. In this architecture, there is only one controller that handles all the requests. This controller is responsible for routing the requests to the appropriate service and action. This makes it easier to maintain and debug the application. This must be one per application.\nTo achieve api versioning, this controller can have multiple actions each pointing to a different version of the application. Each action can then route the request to the appropriate service switch. It is at this point that the app should handle all exceptions that might be raised by the services and then return a 200 OK response with the appropriate message.\nExample using php.\nController\rclass ApiController extends Controller { public function v1() { try { // point to the service switch for version one } catch (\\Exception $e) { // handle the exception here } } public function v2() { try { // point to the service switch for version two } catch (\\Exception $e) { // handle the exception here } } } \u0026lt;?php\rNo logic should be in the controller, it should only be responsible for routing the requests to the appropriate service and action.\nPoint To Ponder!\nThis is the driver in the car scenario. The driver is responsible for routing the police man questions to the appropriate passenger.\nThe steering wheel is the controller action of the version we are targeting!\n7. Single Service Switch Per API Version. In this architecture, there should only be one service switch that handles all the requests for a particular version of the application. This service switch is responsible reading the SERVICE in the request and the call the responsible service passing it the action(ACTION) and the rest of the payload.\nThe service switch is just a convention to make our controller clean and easy to maintain. It is not a must to have it, but it is recommended. Otherwise, the switching logic would be handled in the controller action responsible for the version.\nPoint To Ponder!\nThis is the conductor in the car scenario. However much the driver can do everything the conductor can do, the conductor is their to reduce work load on the driver.\nThis implies the driver focuses on the road and the conductor focuses on the passengers.\nThe controller focuses on the mapping the request, the service switch focuses on mapping the service and the action.\n8. Services and Actions In MoonLight architecture, services are classes or interfaces that combine together related business logic. For example, AuthenticationService, ProductService, OrderService etc.\nActions are methods in these classes like login, register in the AuthenticationService class.\nPoint To Ponder!\nThis is the passenger in the car scenario. The passenger is responsible for their own luggage and reaching their destination. They are also responsible for fullfiling the driver\u0026rsquo;s requests.\nRemember, the driver asks the passenger for the id, the passenger passed it over to the driver! Passing the id is the passenger\u0026rsquo;s responsibility(action).\n9. Database and Querying In moonlight architecture, querying the database is highly recommended over using an ORM. This is because querying the database directly is faster and more efficient than using an ORM. Also, querying the database directly gives the developer more control over the queries and the data being returned.\nGet started with the Moonlight Implementation using Pionia.\n10. Separation of Concerns In this architecture, the backend is meant to support, command and act as a single source of truth for the frontend. This implies that the architecture requires implementers to implement the frontend and backend separately.\nAdvantages of MoonLight Architecture Scalability :- Since adding new services and actions is easy, the application can be scaled easily. Maintainability :- Small codebase and single-logic services make it easy to maintain the application. Even new developers can easily understand the codebase. Security :- Since all requests are made using POST, the data is secure and not exposed in the URL. Also, action level authentication makes it easy to secure the application. High Performance :- This is as a result of less abstraction and more direct database querying. Also, the architecture improves the developer performance since it reduces the codebase of the previously used architectures by almost 60%. Easy Debugging :- Since all requests and responses are made in a similar format, it is easy to debug the application. Frontend Integration :- One endpoint for all requests, one request format, one response format make it easy for frontend devs to integrate the api. Disadvantages of MoonLight Architecture Some languages may not support switching between form-data and json requests. This might dictate all uploads to be base64 encoded. Moonlight is only suitable for APIs and not for fullstack applications. The architecture being new, there might be a learning curve for new developers and a small community to get help from. The community is growing and we are looking forward to having you on board.\n","date":"2024-05-24","id":2,"permalink":"/docs/moonlight/","summary":"MoonLight is a rather new architecture that is based on the commonly used architectures of gRPC, MVC(Model View Controller), Micro-Services and Monolothic.","tags":[],"title":"MoonLight Architecture"},{"content":"Installation Composer ","date":"2023-09-07","id":3,"permalink":"/docs/documentation/","summary":"Installation Composer ","tags":[],"title":"Documentation"},{"content":"\rThis section assumes that you have already setup your pinia framework project. If you haven\u0026rsquo;t done done, please head over to Installation.\nThis guide also introduces you to the implementation of the Moonlight architecture, so you can check it out first to get familiar with the terminologies.\nOut Target We should be able to accomplish the following tasks by the end of this tutorial:\nIntialise the project. Connect to an existing database. Create a todo service. Create a new to-do item in the database. Retrieve all to-do items from the database. Retrieve a single to-do item from the database. Update a to-do item in the database. Delete a to-do item from the database. Prerequisites You should have a basic understanding of PHP. You should have postman installed on your machine for testing the API. You should have a database created already. Step 1: Initialize the project To create a new project, you need to run the following command in the directory you want your project to be created. We are calling ours todo_api.\ncomposer create-project pionia/pionia-app todo_api\rWe can open the project in our favorite code editor or IDE, for this tutorial we will be using PhPStorm IDE.\nAll IDEs and IDEs should be okay to use since Pionia is powered by PHP that is supported by most of the IDEs.\nDirectory structure of the project should look like this:\nFor explanation of the directories and scripts, please refer to the Structure Section of this documentation.\nStep 2: Connect to the database Assuming you have already setup your MySQL database.\nLet\u0026rsquo;s first create our MySQL database as below:\nCREATE DATABASE todo_db; USE todo_db;\rThen we can create a table called todos as below:\ncreate table if not exists todos ( id int auto_increment primary key, title varchar(200) not null, description text, created_at timestamp default CURRENT_TIMESTAMP ); desc todos;\rAbove should return the following:\nOpen settings.ini file and update the database settings as below:\nsettings.ini\r[db] name = \u0026#34;todo_db\u0026#34; user = \u0026#34;root\u0026#34; # your database user driver = \u0026#34;mysql\u0026#34; host = \u0026#34;localhost\u0026#34; password = \u0026#34;\u0026#34; # your database password port = 3306\rStep 3: Create the service - TodoService Since all our business logic is related to To-do items, we only need one service called TodoService. Head over to services directory and add the following code to TodoService.php: All our services should extend BaseRestService class.\n\u0026lt;?php \u0026lt;?php {title=\u0026#34;TodoService.php\u0026#34;} namespace application\\services; use Pionia\\request\\BaseRestService; class TodoService extends BaseRestService { }\rAfter creating our service, we need to register it in the MainApiSwitch class. Open MainApiSwitch.php and add the following code:\nMainApiSwitch.php\rpublic function registerServices(): array { return [ \u0026#39;user\u0026#39; =\u0026gt; new UserService(), \u0026#34;todo\u0026#34; =\u0026gt; new TodoService(), // add this line here ]; }\rNow our service is discoverable by the framework.\nStep 4: Create a new to-do item in the database - 1st action. We create our first action in our service called \u0026lsquo;create\u0026rsquo;. This action will be responsible for creating a new to-do item in the database.\nTodoService.php\rnamespace application\\services; use Pionia\\request\\BaseRestService; class TodoService extends BaseRestService { public function create($data) : BaseResponse { $title = $data[\u0026#39;title\u0026#39;]; $description = $data[\u0026#39;description\u0026#39;]; $builder = new QueryBuilder(); $stmt = $builder-\u0026gt;connection-\u0026gt;prepare(\u0026#34;INSERT INTO todos(title, description) VALUES(:title, :description)\u0026#34;); $stmt-\u0026gt;bindValue(\u0026#39;:title\u0026#39;, $title); $stmt-\u0026gt;bindValue(\u0026#39;:description\u0026#39;, $description); $stmt-\u0026gt;execute(); $lastInserted = $builder-\u0026gt;connection-\u0026gt;lastInsertId(\u0026#39;id\u0026#39;); $inserted = $builder-\u0026gt;one(\u0026#34;SELECT * from todos WHERE id = :id\u0026#34;, [ \u0026#39;id\u0026#39; =\u0026gt; $lastInserted ]); return BaseResponse::JsonResponse(0, \u0026#34;Todo $inserted-\u0026gt;title created.\u0026#34;, $inserted, $lastInserted); } }\rSending the request using any client of choice.\nAxios FormData(postman)\rAxios JSON Data(Postman)\rXHR -JSON (Postman)\rconst axios = require(\u0026#39;axios\u0026#39;); const FormData = require(\u0026#39;form-data\u0026#39;); let data = new FormData(); data.append(\u0026#39;title\u0026#39;, \u0026#39;Pass this \u0026#39;); data.append(\u0026#39;description\u0026#39;, \u0026#39;Must pass this\u0026#39;); data.append(\u0026#39;SERVICE\u0026#39;, \u0026#39;todo\u0026#39;); data.append(\u0026#39;ACTION\u0026#39;, \u0026#39;create\u0026#39;); let config = { method: \u0026#39;post\u0026#39;, maxBodyLength: Infinity, url: \u0026#39;http://localhost:8000/api/v1/\u0026#39;, headers: { ...data.getHeaders() }, data : data }; axios.request(config) .then((response) =\u0026gt; { console.log(JSON.stringify(response.data)); }) .catch((error) =\u0026gt; { console.log(error); });\rconst axios = require(\u0026#39;axios\u0026#39;); let data = JSON.stringify({ \u0026#34;SERVICE\u0026#34;: \u0026#34;todo\u0026#34;, \u0026#34;ACTION\u0026#34;: \u0026#34;create\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;Become an avenger\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Make sure you become an avenger at 10!\u0026#34; }); let config = { method: \u0026#39;post\u0026#39;, maxBodyLength: Infinity, url: \u0026#39;http://localhost:8000/api/v1/\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, data : data }; axios.request(config) .then((response) =\u0026gt; { console.log(JSON.stringify(response.data)); }) .catch((error) =\u0026gt; { console.log(error); });\rvar data = JSON.stringify({ \u0026#34;SERVICE\u0026#34;: \u0026#34;todo\u0026#34;, \u0026#34;ACTION\u0026#34;: \u0026#34;create\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;Become an avenger\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Make sure you become an avenger at 10!\u0026#34; }); var xhr = new XMLHttpRequest(); xhr.withCredentials = true; xhr.addEventListener(\u0026#34;readystatechange\u0026#34;, function() { if(this.readyState === 4) { console.log(this.responseText); } }); xhr.open(\u0026#34;POST\u0026#34;, \u0026#34;http://localhost:8000/api/v1/\u0026#34;); xhr.setRequestHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;);\rOn Successful execution, the above code should return the following:\n{ \u0026#34;returnCode\u0026#34;: 0, \u0026#34;returnMessage\u0026#34;: \u0026#34;Todo Become an avenger created.\u0026#34;, \u0026#34;returnData\u0026#34;: { \u0026#34;id\u0026#34;: 2, \u0026#34;title\u0026#34;: \u0026#34;Become an avenger\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Make sure you become an avenger at 10!\u0026#34;, \u0026#34;created_at\u0026#34;: \u0026#34;2024-05-26 00:11:23\u0026#34; }, \u0026#34;extraData\u0026#34;: \u0026#34;2\u0026#34; }\rAnd in the database, we should have the following:\nBefore we proceed, let\u0026rsquo;s first understand what just happened above.\nWhen you hit the endpoint http://localhost:8000/api/v1/ with the data as shown above, the request came via our index.php, which checked out routes. We only have one route as follows:-\nroutes.php\r$router-\u0026gt;addGroup(\u0026#39;application\\Controller\u0026#39;) -\u0026gt;post(\u0026#39;api_v1\u0026#39;, \u0026#39;api_version_one\u0026#39;);\rThe above route implies that all post requests to our only controller should be handled by an action(method) named \u0026lsquo;api_v1\u0026rsquo;.\nTherefore, in our controller, the following method was executed:\nController.php\rpublic function api_v1(Request $request): BaseResponse { try { return MainApiSwitch::processServices($request); } catch (Exception $e) { return BaseResponse::JsonResponse(400, $e-\u0026gt;getMessage()); } }\rThe above does two things:\nMaps the whole request to the MainApiSwitch class which is responsible for mapping the request to the service mentioned.\nCatches any exception that might be thrown during the process and returns a 200 OK response with a returnCode of 400.\nThe main api switch checks in the request body for the SERVICE and ACTION keys. If they are not found, it throws an exception. If they are found, it maps the request to the service and action mentioned basing on the registered services. Therefore, for your service to be discovered, you must register it as we did here.\nMainApiSwitch.php\rpublic function registerServices(): array { return [ \u0026#39;user\u0026#39; =\u0026gt; new UserService(), \u0026#34;todo\u0026#34; =\u0026gt; new TodoService(), // this is our service. ]; }\rSo, after here, the service needed is loaded and the entire request in forwarded to it. When the service receives the request, it checks for the action mentioned in the request body. If the action is not found, it throws an exception. If the action is found, it executes the action and returns a response back to the MainApiSwitch which then returns the response to the controller which then returns the response to the kernel that does final processing and returns the response to the client.\nStep 5: Retrieve all to-do items from the database - 2nd action. We created our todo from the above step, please first take time to create as many as you want.\nNow, let\u0026rsquo;s create an action called all in our service to retrieve all to-do items from the database.\nTodoService.php\r## ..rest of the service code public function all() : BaseResponse { $builder = new QueryBuilder(); $data = $builder-\u0026gt;all(\u0026#34;SELECT * from todos\u0026#34;); return BaseResponse::JsonResponse(0, \u0026#34;Todos found.\u0026#34;, $data); } ## rest of the service code... Now, let\u0026rsquo;s change our JSON in postman to the following:\n{ \u0026#34;SERVICE\u0026#34;: \u0026#34;todo\u0026#34;, \u0026#34;ACTION\u0026#34;: \u0026#34;all\u0026#34; }\rSend the request and you should get the following response:\n{ \u0026#34;returnCode\u0026#34;: 0, \u0026#34;returnMessage\u0026#34;: \u0026#34;Todos found.\u0026#34;, \u0026#34;returnData\u0026#34;: [ { \u0026#34;id\u0026#34;: 1, \u0026#34;title\u0026#34;: \u0026#34;Pass this \u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Must pass this\u0026#34;, \u0026#34;created_at\u0026#34;: \u0026#34;2024-05-26 00:04:17\u0026#34; }, { \u0026#34;id\u0026#34;: 2, \u0026#34;title\u0026#34;: \u0026#34;Become an avenger\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Make sure you become an avenger at 10!\u0026#34;, \u0026#34;created_at\u0026#34;: \u0026#34;2024-05-26 00:11:23\u0026#34; } ], \u0026#34;extraData\u0026#34;: null }\rPoint To Ponder\nNotice how the returnData is an array yet it was an object in the previous response. returnData and extraData can be of any type, it is up to you to decide what to return in them.\nYou can also omit the message by setting it to null which should be logical for cases of listing items.\nStep 6: Retrieve a single to-do item from the database - 3rd action. We will create an action called one in our service to retrieve a single to-do item from the database.\nTodoService.php\r## ..rest of the service code /** * @throws DatabaseException */ public function one($data) : BaseResponse { $id = $data[\u0026#39;id\u0026#39;]; $builder = new QueryBuilder(); $res = $builder-\u0026gt;one(\u0026#34;SELECT * from todos WHERE id = :id\u0026#34;, [ \u0026#39;id\u0026#39; =\u0026gt; $id ]); if ($res) { return BaseResponse::JsonResponse(0, null, $data); } else { throw new DatabaseException(\u0026#34;No todo with id $id found.\u0026#34;); } } ## ..rest of the service code Here we are going to test two scenarios, one is where everything goes smoothly and the other is where the server panics(throws an exception).\n{ \u0026#34;SERVICE\u0026#34;:\u0026#34;todo\u0026#34;, \u0026#34;ACTION\u0026#34;: \u0026#34;one\u0026#34;, \u0026#34;id\u0026#34;: 2 }\r{ \u0026#34;SERVICE\u0026#34;: \u0026#34;todo\u0026#34;, \u0026#34;ACTION\u0026#34;: \u0026#34;one\u0026#34;, \u0026#34;id\u0026#34;: 100 }\rIn the first scenario, we get back a status code of 200 OK but with the following response.\n{ \u0026#34;returnCode\u0026#34;: 0, \u0026#34;returnMessage\u0026#34;: null, \u0026#34;returnData\u0026#34;: { \u0026#34;SERVICE\u0026#34;: \u0026#34;todo\u0026#34;, \u0026#34;ACTION\u0026#34;: \u0026#34;one\u0026#34;, \u0026#34;id\u0026#34;: 2 }, \u0026#34;extraData\u0026#34;: null }\rBut in the second scenario, we still get a status code of 200 OK but with the following response.\n{ \u0026#34;returnCode\u0026#34;: 400, \u0026#34;returnMessage\u0026#34;: \u0026#34;No todo with id 100 found.\u0026#34;, \u0026#34;returnData\u0026#34;: null, \u0026#34;extraData\u0026#34;: null }\rPoint To Ponder\nNotice how the exception message becomes our returnMessage. This exception was caught by our controller. Therefore, wherever you\u0026rsquo;re in the services, feel free to throw any exceptions with clean messages.\nStep 7: Update a to-do item in the database - 4th action. However much this would endup being an independent action of its own, we are going to use the same action create to update our to-do item.\nTodoService.php\r1## ..rest of the service code 2 3public function create($data) : BaseResponse 4 { 5 $title = $data[\u0026#39;title\u0026#39;]; 6 $description = $data[\u0026#39;description\u0026#39;]; 7 8 $builder = new QueryBuilder(); 9 10 $id = $data[\u0026#39;id\u0026#39;] ?? null; 11 12 if ($id){ 13 // here we are updating 14 $stmt = $builder-\u0026gt;connection-\u0026gt;prepare(\u0026#34;UPDATE todos SET title = :title, description = :description WHERE id = :id\u0026#34;); 15 $stmt-\u0026gt;bindParam(\u0026#39;:id\u0026#39;, $id); 16 } else { 17 // here we are creating 18 $stmt = $builder-\u0026gt;connection-\u0026gt;prepare(\u0026#34;INSERT INTO todos(title, description) VALUES(:title, :description)\u0026#34;); 19 } 20 21 $stmt-\u0026gt;bindValue(\u0026#39;:title\u0026#39;, $title); 22 $stmt-\u0026gt;bindValue(\u0026#39;:description\u0026#39;, $description); 23 24 $stmt-\u0026gt;execute(); 25 26 $lastInserted = $id ?? $builder-\u0026gt;connection-\u0026gt;lastInsertId(\u0026#39;id\u0026#39;); 27 28 $inserted = $builder-\u0026gt;one(\u0026#34;SELECT * from todos WHERE id = :id\u0026#34;, [ \u0026#39;id\u0026#39; =\u0026gt; $lastInserted ]); 29 30 return BaseResponse::JsonResponse(0, \u0026#34;Todo $inserted-\u0026gt;title created.\u0026#34;, $inserted, $lastInserted); 31 } 32 ## ..rest of the service code Changed/Added lines are highlighted. The above should be returning the following:\n{ \u0026#34;returnCode\u0026#34;: 0, \u0026#34;returnMessage\u0026#34;: \u0026#34;Todo Become an avenger-updated created.\u0026#34;, \u0026#34;returnData\u0026#34;: { \u0026#34;id\u0026#34;: 2, \u0026#34;title\u0026#34;: \u0026#34;Become an avenger-updated\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Make sure you become an avenger at 10!\u0026#34;, \u0026#34;created_at\u0026#34;: \u0026#34;2024-05-26 00:11:23\u0026#34; }, \u0026#34;extraData\u0026#34;: \u0026#34;2\u0026#34; }\rStep 8: Delete a to-do item from the database - 5th action. If you followed along upto this far, you should be able to implement this on your own. If you get stuck, you can refer to the code below.\nTodoService.php\rpublic function delete($data) : BaseResponse { $id = $data[\u0026#39;id\u0026#39;]; $builder = new QueryBuilder(); $res = $builder-\u0026gt;connection-\u0026gt;prepare(\u0026#34;DELETE FROM todos WHERE id = :id\u0026#34;); $res-\u0026gt;bindParam(\u0026#39;:id\u0026#39;, $id); $res-\u0026gt;execute(); return BaseResponse::JsonResponse(0, \u0026#34;Todo deleted.\u0026#34;); }\rChange your request object to the following in your client(postman).\n{ \u0026#34;SERVICE\u0026#34;: \u0026#34;todo\u0026#34;, \u0026#34;ACTION\u0026#34;: \u0026#34;delete\u0026#34;, \u0026#34;id\u0026#34;: 2 }\rIf you did everything right, you should get your response as follows\n{ \u0026#34;returnCode\u0026#34;: 0, \u0026#34;returnMessage\u0026#34;: \u0026#34;Todo deleted.\u0026#34;, \u0026#34;returnData\u0026#34;: null, \u0026#34;extraData\u0026#34;: null }\rPoint To Ponder\nAll our requests are made via POST method. All our requests have similar body structure, they have a SERVICE, ACTION, and other param keys. All our responses have the same response format, returnCode, returnMessage, returnData, and extraData keys. We are hitting the same endpoint http://localhost:8000/api/v1/ for all our requests. We did not touch the controller, routes, or the kernel. but we only focused on the service. This is the beaty of the Moonlight architecture. It makes it easy to understand and maintain your code.\nImagine how fast you would pull off a new feature with Pionia.\nTutorial Source Code Details\rTodoService.php\r\u0026lt;?php namespace application\\services; use Pionia\\database\\QueryBuilder; use Pionia\\exceptions\\DatabaseException; use Pionia\\request\\BaseRestService; use Pionia\\response\\BaseResponse; class TodoService extends BaseRestService { public function create($data) : BaseResponse { $title = $data[\u0026#39;title\u0026#39;]; $description = $data[\u0026#39;description\u0026#39;]; $builder = new QueryBuilder(); $id = $data[\u0026#39;id\u0026#39;] ?? null; if ($id){ // here we are updating $stmt = $builder-\u0026gt;connection-\u0026gt;prepare(\u0026#34;UPDATE todos SET title = :title, description = :description WHERE id = :id\u0026#34;); $stmt-\u0026gt;bindParam(\u0026#39;:id\u0026#39;, $id); } else { // here we are creating $stmt = $builder-\u0026gt;connection-\u0026gt;prepare(\u0026#34;INSERT INTO todos(title, description) VALUES(:title, :description)\u0026#34;); } $stmt-\u0026gt;bindValue(\u0026#39;:title\u0026#39;, $title); $stmt-\u0026gt;bindValue(\u0026#39;:description\u0026#39;, $description); $stmt-\u0026gt;execute(); $lastInserted = $id ?? $builder-\u0026gt;connection-\u0026gt;lastInsertId(\u0026#39;id\u0026#39;); $inserted = $builder-\u0026gt;one(\u0026#34;SELECT * from todos WHERE id = :id\u0026#34;, [ \u0026#39;id\u0026#39; =\u0026gt; $lastInserted ]); return BaseResponse::JsonResponse(0, \u0026#34;Todo $inserted-\u0026gt;title created.\u0026#34;, $inserted, $lastInserted); } public function all() : BaseResponse { $builder = new QueryBuilder(); $data = $builder-\u0026gt;all(\u0026#34;SELECT * from todos\u0026#34;); return BaseResponse::JsonResponse(0, \u0026#34;Todos found.\u0026#34;, $data); } /** * @throws DatabaseException */ public function one($data) : BaseResponse { $id = $data[\u0026#39;id\u0026#39;]; $builder = new QueryBuilder(); $res = $builder-\u0026gt;one(\u0026#34;SELECT * from todos WHERE id = :id\u0026#34;, [ \u0026#39;id\u0026#39; =\u0026gt; $id ]); if ($res) { return BaseResponse::JsonResponse(0, null, $data); } else { throw new DatabaseException(\u0026#34;No todo with id $id found.\u0026#34;); } } public function delete($data) : BaseResponse { $id = $data[\u0026#39;id\u0026#39;]; $builder = new QueryBuilder(); $res = $builder-\u0026gt;connection-\u0026gt;prepare(\u0026#34;DELETE FROM todos WHERE id = :id\u0026#34;); $res-\u0026gt;bindParam(\u0026#39;:id\u0026#39;, $id); $res-\u0026gt;execute(); return BaseResponse::JsonResponse(0, \u0026#34;Todo deleted.\u0026#34;); } }\rPost Tutorial \u0026ndash; What Next? Deep Dive into Pionia Requests\rExplore more features about the Pionia Requests and the request cycle.\n","date":"2024-05-24","id":4,"permalink":"/documentation/api-tutorial/","summary":"This section assumes that you have already setup your pinia framework project.","tags":[],"title":"API Tutorial"},{"content":"\rAbout Welcome to the official documentation of pionia - /ˌpʌɪəˈnɪə/ framework. Pionia is a PHP Rest Framework that is truly RESTful. It is designed to be simple, lightweight, and easy to use. Pionia is built on top of the Moonlight architecture, which is a powerful architecture for powering highly scaling REST projects. Pionia provides a set of tools and conventions that make it easy to build RESTful APIs in PHP.\nThis framework was born at Service Cops - East Africa by JET and is maintained by the same team. The framework is open-source and is released under the MIT license.\nDocumentation organisation.\nMoonLight Architecture Tutorial Directory Structure Requests Responses Middleware Authentication and Authorization Validation Error Handling Service Swapping The Controller Services and Actions Database and Querying API Reference Get Started Start with a TO-DO api tutorial\nYou can quickly get started with our To-Do API tutorial. This guide introduces you to the both the framework and the Moonlight architecture. It is the recommended way to start your pionia jungle journey.\nWhy Pionia? There are various reasons why pionia stands out from other PHP frameworks. From program performance, developer performance, to maintainability, pionia has got you covered.\nYou can read more about why pionia.\nInstallation Pre-requisites PHP 8.0 or higher Any web server (Apache, Nginx, etc.) for production Composer Any of Postgres, MySQL, or SQLite Note: This guide assumes you have Composer installed and running globally. If you don\u0026rsquo;t, you can download it from getcomposer.org or use the Composer Docker image.\ncomposer\rGit templates\rcomposer create-project pionia/pionia-app my-project\rRemember to replace my-project with the name of your project.\nSelect use this template on the repository page. Download directly the compressed file from the releases page. Nginx configurationss\nThis is just a sample configuration. You can modify it to suit your needs. But make sure your configuration points to the index.php file of your project.\n# ...rest of your configurations # projet_name [replace this with your project name] location /projet_name { alias /var/www/html/project_name; try_files $uri $uri/ @project_name; } location @camera_track { rewrite /project_name/(.*)$ /project_name/index.php?/$1 last; } ## ...rest of your configurations\rContributing Currently the framework is maintained at Service Cops - East Africa but we welcome contributors from all walks of life.\nYou can contribute to the framework, documentation or by helping us grow the community through writing articles, tutorials, and sharing your experience with the framework on any media platform.\nThe framework itself strips off all the unnecessary features that are found in other frameworks and leaves you with only what you need to build a RESTful API. This means you can also contribute by building plugins and extensions that can be used with the framework.\nIf you want to contribute to this documentation, you can find the source code on GitHub.\nPlease read the contributing guidelines before contributing.\nPlease note that this project is released with a Contributor Code of Conduct\n","date":"2024-05-24","id":5,"permalink":"/documentation/introduction/","summary":"About Welcome to the official documentation of pionia - /ˌpʌɪəˈnɪə/ framework.","tags":[],"title":"Introduction"},{"content":"\rHandling Requests Coming soon\u0026hellip;\n","date":"2024-05-24","id":6,"permalink":"/documentation/requests/","summary":"Handling Requests Coming soon\u0026hellip;","tags":[],"title":"Requests"},{"content":"Taking our directory structure from the API Tutorial we created here.\nDirectory Structure Breakdown app:- This is the main directory of the project. It is where all the application logic is stored. It contains the following subdirectories and scripts:\nController.php :- This file contains the only controller our project needs and runs. Controllers are responsible for mapping traffic to the responsible service switcher. routes.php :- This file contains the route(s) that our apps will use to access the controller. In normal curcumstances, it should be always one route. MainApiSwitch.php :- This is where all our services are registered and called. It is where we switch between services basing on the request made. services :- This is where all our services are stored. This is where you should focus most. All business logic resides here. authenticationBackends :- This is where we store our authentication backends reside. Add your authentication logic here. middlewares :- Usually this folder is not included in the initial project setup. But this is where you add your middlewares. Middlewares are used to intercept requests before they reach the controller and after they leave the controller. vendor:- This is where all the dependencies of the project are stored. It is created by composer when you run composer install or composer update.\n.gitignore:- This file is used to tell git which files to ignore when pushing to the repository.\ncomposer.json:- This file is used to manage the dependencies of the project. It is used by composer to install the dependencies.\ncomposer.lock:- This file is used to lock the dependencies of the project. It is used by composer to install the dependencies.\nindex.php:- This is the entry point of the project. It is where the project starts running. This is where you register the middlewares, routes, and authentication backends.\npionia:- This is our console interface. It helps us to run pionia-specific commands.\nREADME.md:- This is the file that contains the documentation of the project. It is the first file that is opened when you open the project.\nsettings.ini:- This is the file that contains the settings of the project. It is where you store the settings of the project.\nAs you can see, pionia maintains the least number of files and directories to make it easy for you to understand and maintain your project. You can always add more directories and files as you see fit. But remember to keep the project as simple as possible.\n","date":"2024-05-24","id":7,"permalink":"/documentation/structure/","summary":"Taking our directory structure from the API Tutorial we created here.","tags":[],"title":"Structure"},{"content":"","date":"2023-09-07","id":8,"permalink":"/docs/reference/","summary":"","tags":[],"title":"Reference"},{"content":"Reference pages are ideal for outlining how things work in terse and clear terms. Less concerned with telling a story or addressing a specific use case, they should give a comprehensive outline of what your documenting.\nFurther reading Read about reference in the Diátaxis framework ","date":"2023-09-07","id":9,"permalink":"/reference/example-reference/","summary":"Reference pages are ideal for outlining how things work in terse and clear terms.","tags":[],"title":"Example Reference"},{"content":"We shall be updating this page with resources that will help you enhance your Pionia Framework journey.\n","date":"2024-02-27","id":10,"permalink":"/resources/","summary":"We shall be updating this page with resources that will help you enhance your Pionia Framework journey.","tags":[],"title":"Resources"},{"content":"","date":"2023-09-07","id":11,"permalink":"/docs/","summary":"","tags":[],"title":"Docs"},{"content":"Privacy Policy ","date":"2023-09-07","id":12,"permalink":"/privacy/","summary":"Privacy Policy ","tags":[],"title":"Privacy Policy"},{"content":"\rcomposer create-project pionia/pionia-app my_beautiful_project #replace my_beautiful_project with your project name\rPionia Framework Pionia is the first PHP Rest Framework that is truly RESTful. It is designed to be simple, lightweight, and easy to use. Pionia is built on top of the Moonlight architecture, which is a powerful architecture for powering highly scaling REST projects. Pionia provides a set of tools and conventions that make it easy to build RESTful APIs in PHP.\nWhy Pionia? ","date":"2023-09-07","id":13,"permalink":"/","summary":"composer create-project pionia/pionia-app my_beautiful_project #replace my_beautiful_project with your project name\rPionia Framework Pionia is the first PHP Rest Framework that is truly RESTful.","tags":[],"title":"Pionia Framework"},{"content":"","date":"0001-01-01","id":14,"permalink":"/categories/","summary":"","tags":[],"title":"Categories"},{"content":"","date":"0001-01-01","id":15,"permalink":"/contributors/","summary":"","tags":[],"title":"Contributors"},{"content":"","date":"0001-01-01","id":16,"permalink":"/tags/","summary":"","tags":[],"title":"Tags"}]